<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
    <meta charset="UTF-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ ÿ™ÿ≠ŸÑ€åŸÑ‚Äå⁄Øÿ± Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá ÿ¥ÿ®⁄©Ÿá - ŸÜÿ≥ÿÆŸá ⁄©ÿßŸÖŸÑ</title>  
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script> 
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/date-fns/2.29.3/index.min.js"></script> 
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box; 
        }

        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #06d6a0;
            --danger: #ef476f;
            --warning: #f78c6b;
            --info: #118ab2;
            --dark: #073b4c;
            --light: #f8f9fa;
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #06d6a0 0%, #118ab2 100%);
            --glass-bg: rgba(255, 255, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.18);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--gradient-primary);
            min-height: 100vh;
            color: var(--dark);
            direction: rtl;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: var(--gradient-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            border: 2px dashed var(--primary);
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            background: rgba(255, 255, 255, 0.95); 
            transform: translateY(-2px);
        }

        .upload-area {
            padding: 40px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area.dragover {
            background: rgba(6, 214, 160, 0.1);
            border-color: var(--success);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
            margin: 5px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn.success {
            background: var(--gradient-success); 
        }

        .btn.warning {
            background: linear-gradient(135deg, #f78c6b, #ffc107);
        }

        .btn.danger {
            background: linear-gradient(135deg, #ef476f, #dc3545);
        }

        .btn.secondary {
            background: linear-gradient(135deg, #6c757d, #868e96);
        }

        .date-range-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .date-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .date-input-group {
            display: flex;
            flex-direction: column;
        }

        .date-input-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--dark);
        }

        .date-input-group input {
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .date-input-group input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .quick-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            margin-top: 20px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .stat-label {
            color: #6c757d;
            font-weight: 500;
        }

        .stat-change {
            font-size: 0.9rem;
            margin-top: 5px;
        }

        .stat-change.positive {
            color: var(--success);
        }

        .stat-change.negative {
            color: var(--danger);
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            min-height: 400px;
        }

        .chart-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f3f4;
        }

        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .device-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border-left: 4px solid var(--primary);
        }

        .device-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .device-card.excellent { border-left-color: var(--success); }
        .device-card.good { border-left-color: #28a745; }
        .device-card.fair { border-left-color: var(--warning); }
        .device-card.poor { border-left-color: var(--danger); }

        .device-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .device-name {
            font-weight: 700;
            color: var(--dark);
        }

        .device-status {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-online {
            background: rgba(6, 214, 160, 0.1);
            color: var(--success);
        }

        .status-offline {
            background: rgba(239, 71, 111, 0.1);
            color: var(--danger);
        }

        .device-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
        }

        .metric-label {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.8s ease;
            border-radius: 4px;
        }

        .progress-excellent { background: var(--gradient-success); }
        .progress-good { background: linear-gradient(90deg, #28a745, #20c997); }
        .progress-fair { background: linear-gradient(90deg, #ffc107, #fd7e14); }
        .progress-poor { background: linear-gradient(90deg, #fd7e14, #dc3545); }

        .loading {
            display: none;
            text-align: center;
            padding: 50px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 5px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .tab {
            flex: 1;
            padding: 12px 20px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            min-width: 120px;
        }

        .tab.active {
            background: var(--gradient-primary);
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .time-series-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .downtime-analysis {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .downtime-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        .downtime-table th,
        .downtime-table td {
            padding: 12px;
            text-align: right;
            border-bottom: 1px solid #e9ecef;
        }

        .downtime-table th {
            background: #f8f9fa;
            font-weight: 600;
            color: var(--dark);
        }

        .downtime-duration {
            font-weight: 700;
        }

        .duration-short { color: var(--success); }
        .duration-medium { color: var(--warning); }
        .duration-long { color: var(--danger); }

        .filter-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .search-input {
            width: 100%;
            max-width: 400px;
            padding: 12px 20px;
            border: 2px solid #e9ecef;
            border-radius: 25px;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .search-input:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .filter-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .filter-btn {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            color: #495057;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
        }

        .filter-btn:hover,
        .filter-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .export-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-top: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .export-buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .export-btn {
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .export-btn.excel {
            background: linear-gradient(135deg, #28a745, #20c997);
        }

        .export-btn.pdf {
            background: linear-gradient(135deg, #dc3545, #e55353);
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-info {
            background: rgba(17, 138, 178, 0.1);
            color: var(--info);
            border: 1px solid rgba(17, 138, 178, 0.3);
        }

        .alert-success {
            background: rgba(6, 214, 160, 0.1);
            color: var(--success);
            border: 1px solid rgba(6, 214, 160, 0.3);
        }

        .alert-warning {
            background: rgba(247, 140, 107, 0.1);
            color: var(--warning);
            border: 1px solid rgba(247, 140, 107, 0.3);
        }

        .alert-danger {
            background: rgba(239, 71, 111, 0.1);
            color: var(--danger);
            border: 1px solid rgba(239, 71, 111, 0.3);
        }

        @media (max-width: 768px) {
            .charts-grid, .stats-grid {
                grid-template-columns: 1fr;
            }

            .header h1 {
                font-size: 2rem;
            }

            .device-metrics {
                grid-template-columns: 1fr;
            }

            .tabs {
                flex-direction: column;
            }

            .date-controls {
                grid-template-columns: 1fr;
            }

            .quick-filters {
                justify-content: flex-start;
            }
        }

        .comparison-section {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .comparison-controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .select-group {
            display: flex;
            flex-direction: column;
        }

        .select-group label {
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--dark);
        }

        .select-group select {
            padding: 10px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-size: 1rem;
            outline: none;
            transition: all 0.3s ease;
        }

        .select-group select:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .performance-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-left: 8px;
        }

        .indicator-excellent { background-color: var(--success); }
        .indicator-good { background-color: #28a745; }
        .indicator-fair { background-color: var(--warning); }
        .indicator-poor { background-color: var(--danger); }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--dark);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.8rem;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 1000;
        }

        .tooltip:hover::after {
            opacity: 1;
            visibility: visible;
        }

        .live-indicator {
            position: fixed;
            top: 20px;
            left: 20px;
            background: var(--success);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.8rem;
            font-weight: 600;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .live-indicator.show {
            opacity: 1;
        }

        .live-indicator::before {
            content: '‚óè';
            margin-left: 8px;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .data-summary {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
        }

        .summary-item {
            text-align: center;
            padding: 20px;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .summary-item:hover {
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        .summary-value {
            font-size: 2rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .summary-label {
            color: #6c757d;
            font-weight: 500;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Header -->
        <div class="header">
            <h1>üöÄ ÿ™ÿ≠ŸÑ€åŸÑ‚Äå⁄Øÿ± Ÿæ€åÿ¥ÿ±ŸÅÿ™Ÿá ÿ¥ÿ®⁄©Ÿá - ŸÜÿ≥ÿÆŸá ⁄©ÿßŸÖŸÑ</h1>
            <p>ÿ™ÿ≠ŸÑ€åŸÑ ÿ¨ÿßŸÖÿπ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ¥ÿ®⁄©Ÿá ÿ®ÿß ÿßŸÖ⁄©ÿßŸÜ ÿßŸÜÿ™ÿÆÿßÿ® ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å ÿØŸÑÿÆŸàÿßŸá</p>
        </div>

        <!-- Upload Section -->
        <div class="upload-section" id="uploadSection">
            <div class="upload-area" id="uploadArea">
                <h3>üìÅ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿ¥ÿ®⁄©Ÿá</h3>
                <p>ŸÅÿß€åŸÑ CSV ÿÆŸàÿØ ÿ±ÿß ⁄©ÿ¥€åÿØŸá Ÿà ÿ±Ÿáÿß ⁄©ŸÜ€åÿØ €åÿß ⁄©ŸÑ€å⁄© ⁄©ŸÜ€åÿØ</p>
                <input type="file" id="fileInput" class="file-input" accept=".csv">
                <br><br>
                <button class="btn" onclick="document.getElementById('fileInput').click()">
                    ÿßŸÜÿ™ÿÆÿßÿ® ŸÅÿß€åŸÑ CSV
                </button>
                <div style="margin-top: 15px;">
                    <button class="btn secondary" onclick="loadSampleData()">
                        üìä ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿØÿßÿØŸá ŸÜŸÖŸàŸÜŸá
                    </button>
                    <button class="btn success" onclick="showDataFormat()">
                        ‚ùì ÿ±ÿßŸáŸÜŸÖÿß€å ŸÅÿ±ŸÖÿ™ ÿØÿßÿØŸá
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading -->
        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p>ÿØÿ± ÿ≠ÿßŸÑ ÿ™ÿ≠ŸÑ€åŸÑ ÿØÿßÿØŸá‚ÄåŸáÿß€å ÿ¥ÿ®⁄©Ÿá...</p>
        </div>

        <!-- Results Section -->
        <div id="results" class="hidden">
            <!-- Date Range Controls -->
            <div class="date-range-section">
                <h3>üóìÔ∏è ÿßŸÜÿ™ÿÆÿßÿ® ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å</h3>
                <div class="date-controls">
                    <div class="date-input-group">
                        <label for="startDate">ÿ™ÿßÿ±€åÿÆ ÿ¥ÿ±Ÿàÿπ:</label>
                        <input type="date" id="startDate">
                    </div>
                    <div class="date-input-group">
                        <label for="endDate">ÿ™ÿßÿ±€åÿÆ Ÿæÿß€åÿßŸÜ:</label>
                        <input type="date" id="endDate">
                    </div>
                    <div class="date-input-group">
                        <label for="timeRange">ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å:</label>
                        <select id="timeRange">
                            <option value="all">ŸáŸÖŸá ÿØÿßÿØŸá‚ÄåŸáÿß</option>
                            <option value="7">7 ÿ±Ÿàÿ≤ ⁄Øÿ∞ÿ¥ÿ™Ÿá</option>
                            <option value="14">14 ÿ±Ÿàÿ≤ ⁄Øÿ∞ÿ¥ÿ™Ÿá</option>
                            <option value="30">30 ÿ±Ÿàÿ≤ ⁄Øÿ∞ÿ¥ÿ™Ÿá</option>
                            <option value="90">3 ŸÖÿßŸá ⁄Øÿ∞ÿ¥ÿ™Ÿá</option>
                            <option value="custom">ÿ®ÿßÿ≤Ÿá ÿØŸÑÿÆŸàÿßŸá</option>
                        </select>
                    </div>
                </div>
                <div class="quick-filters">
                    <button class="btn" onclick="setQuickRange(1)">ÿßŸÖÿ±Ÿàÿ≤</button>
                    <button class="btn" onclick="setQuickRange(7)">ŸáŸÅÿ™Ÿá ⁄Øÿ∞ÿ¥ÿ™Ÿá</button>
                    <button class="btn" onclick="setQuickRange(30)">ŸÖÿßŸá ⁄Øÿ∞ÿ¥ÿ™Ÿá</button>
                    <button class="btn secondary" onclick="applyDateFilter()">ÿßÿπŸÖÿßŸÑ ŸÅ€åŸÑÿ™ÿ±</button>
                    <button class="btn warning" onclick="resetDateFilter()">ÿ®ÿßÿ≤ŸÜÿ¥ÿßŸÜ€å</button>
                </div>
            </div>

            <!-- Data Summary -->
            <div class="data-summary" id="dataSummary">
                <h3>üìã ÿÆŸÑÿßÿµŸá ÿØÿßÿØŸá‚ÄåŸáÿß ÿØÿ± ÿ®ÿßÿ≤Ÿá ÿßŸÜÿ™ÿÆÿßÿ®€å</h3>
                <div class="summary-grid" id="summaryGrid">
                    <!-- Summary items will be populated here -->
                </div>
            </div>

            <!-- Filter Section -->
            <div class="filter-section">
                <input type="text" class="search-input" placeholder="üîç ÿ¨ÿ≥ÿ™ÿ¨Ÿà€å ÿØÿ≥ÿ™⁄ØÿßŸá..." id="deviceSearch">
                <div class="filter-buttons">
                    <button class="filter-btn active" data-filter="all">ŸáŸÖŸá ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß</button>
                    <button class="filter-btn" data-filter="excellent">ÿπÿßŸÑ€å</button>
                    <button class="filter-btn" data-filter="good">ÿÆŸàÿ®</button>
                    <button class="filter-btn" data-filter="fair">ŸÖÿ™Ÿàÿ≥ÿ∑</button>
                    <button class="filter-btn" data-filter="poor">ÿ∂ÿπ€åŸÅ</button>
                    <button class="filter-btn" data-filter="online">ÿ¢ŸÜŸÑÿß€åŸÜ</button>
                    <button class="filter-btn" data-filter="offline">ÿ¢ŸÅŸÑÿß€åŸÜ</button>
                </div>
            </div>

            <!-- Stats Cards -->
            <div class="stats-grid" id="statsGrid">
                <!-- Stats will be populated here -->
            </div>

            <!-- Tabs -->
            <!-- Tabs -->
            <div class="tabs">
                <div class="tab active" onclick="showTab('overview', this)">üìä ŸÜŸÖÿß€å ⁄©ŸÑ€å</div>
                <div class="tab" onclick="showTab('devices', this)">üñ•Ô∏è ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß</div>
                <div class="tab" onclick="showTab('timeseries', this)">üìà ÿ™ÿ≠ŸÑ€åŸÑ ÿ≤ŸÖÿßŸÜ€å</div>
                <div class="tab" onclick="showTab('downtime', this)">‚è∞ ÿ™ÿ≠ŸÑ€åŸÑ ŸÇÿ∑ÿπ</div>
                <div class="tab" onclick="showTab('comparison', this)">üîÑ ŸÖŸÇÿß€åÿ≥Ÿá</div>
                <div class="tab" onclick="showTab('network', this)">üåê ÿ¥ÿ®⁄©Ÿá</div>
                <div class="tab" onclick="showTab('reports', this)">üìã ⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™</div>
            </div>

            <!-- Tab Contents -->
            <div id="overview" class="tab-content active">
                <div class="charts-grid">
                    <div class="chart-container">
                        <h3 class="chart-title">üìä Ÿàÿ∂ÿπ€åÿ™ ⁄©ŸÑ€å ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß</h3>
                        <div id="statusChart"></div>
                    </div>
                    <div class="chart-container">
                        <h3 class="chart-title">‚è±Ô∏è ÿ±ŸàŸÜÿØ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ</h3>
                        <div id="responseTimeChart"></div>
                    </div>
                    <div class="chart-container">
                      <h3 class="chart-title">üïí ÿßŸÑ⁄ØŸà€å ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ≥ÿßÿπÿ™€å</h3>
                       <div id="hourlyChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üå°Ô∏è ŸÜŸÇÿ¥Ÿá ÿ≠ÿ±ÿßÿ±ÿ™€å ÿπŸÖŸÑ⁄©ÿ±ÿØ</h3>
                       <div id="heatmapChart"></div>
                   </div>
               </div>
           </div>

           <div id="devices" class="tab-content">
               <div class="device-grid" id="deviceGrid">
                   <!-- Device cards will be populated here -->
               </div>
           </div>

           <div id="timeseries" class="tab-content">
               <div class="time-series-section">
                   <h3>üìà ÿ™ÿ≠ŸÑ€åŸÑ ÿ≥ÿ±€å ÿ≤ŸÖÿßŸÜ€å</h3>
                   <div class="alert alert-info">
                       ŸÜŸÖŸàÿØÿßÿ±Ÿáÿß€å ÿ≤€åÿ± Ÿàÿ∂ÿπ€åÿ™ ÿ¢ŸÜŸÑÿß€åŸÜ/ÿ¢ŸÅŸÑÿß€åŸÜ Ÿà ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß ÿ±ÿß ÿØÿ± ÿ∑ŸàŸÑ ÿ≤ŸÖÿßŸÜ ŸÜÿ¥ÿßŸÜ ŸÖ€å‚ÄåÿØŸáŸÜÿØ.
                   </div>
                   <div class="charts-grid">
                       <div class="chart-container">
                           <h3 class="chart-title">üìÖ Ÿàÿ∂ÿπ€åÿ™ ÿ±Ÿàÿ≤ÿßŸÜŸá ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß</h3>
                           <div id="dailyStatusChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">‚è∞ ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ ÿ±Ÿàÿ≤ÿßŸÜŸá</h3>
                           <div id="dailyUptimeChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">üìä ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß ÿØÿ± Ÿáÿ± ÿ±Ÿàÿ≤</h3> 
                           <div id="dailyOutagesChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">üîÑ ŸÖŸÇÿß€åÿ≥Ÿá ŸáŸÅÿ™⁄Ø€å</h3>
                           <div id="weeklyComparisonChart"></div>
                       </div>
                   </div>
               </div>
           </div>

           <div id="downtime" class="tab-content">
               <div class="downtime-analysis">
                   <h3>‚è∞ ÿ™ÿ≠ŸÑ€åŸÑ ÿ¨ÿßŸÖÿπ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß</h3>
                   <div class="charts-grid">
                       <div class="chart-container">
                           <h3 class="chart-title">üìä ÿ™Ÿàÿ≤€åÿπ ŸÖÿØÿ™ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß</h3>
                           <div id="downtimeDurationChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">üïí ÿßŸÑ⁄ØŸà€å ÿ≥ÿßÿπÿ™€å ŸÇÿ∑ÿπ€å‚ÄåŸáÿß</h3>
                           <div id="downtimeHourlyChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">üìÖ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß€å ÿ±Ÿàÿ≤ÿßŸÜŸá</h3>
                           <div id="downtimeDailyChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">üîù ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å Ÿæÿ±ŸÇÿ∑ÿπ€å</h3>
                           <div id="topDowntimeDevicesChart"></div>
                       </div>
                   </div>

                   <div style="margin-top: 30px;">
                       <h4>üìã ÿ¨ÿ≤ÿ¶€åÿßÿ™ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß</h4>
                       <table class="downtime-table" id="downtimeTable">
                           <thead>
                               <tr>
                                   <th>ÿØÿ≥ÿ™⁄ØÿßŸá</th>
                                   <th>ÿ¥ÿ±Ÿàÿπ ŸÇÿ∑ÿπ€å</th>
                                   <th>Ÿæÿß€åÿßŸÜ ŸÇÿ∑ÿπ€å</th>
                                   <th>ŸÖÿØÿ™ ŸÇÿ∑ÿπ€å</th>
                                   <th>ŸÜŸàÿπ</th>
                                   <th>ÿ™ÿ£ÿ´€åÿ±</th>
                               </tr>
                           </thead>
                           <tbody id="downtimeTableBody">
                               <!-- Downtime records will be populated here -->
                           </tbody>
                       </table>
                   </div>
               </div>
           </div>

           <div id="comparison" class="tab-content">
               <div class="comparison-section">
                   <h3>üîÑ ŸÖŸÇÿß€åÿ≥Ÿá ÿπŸÖŸÑ⁄©ÿ±ÿØ</h3>
                   <div class="comparison-controls">
                       <div class="select-group">
                           <label for="comparisonType">ŸÜŸàÿπ ŸÖŸÇÿß€åÿ≥Ÿá:</label>
                           <select id="comparisonType">
                               <option value="devices">ŸÖŸÇÿß€åÿ≥Ÿá ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß</option>
                               <option value="gateways">ŸÖŸÇÿß€åÿ≥Ÿá ⁄Ø€åÿ™‚ÄåŸà€å‚ÄåŸáÿß</option>
                               <option value="subnets">ŸÖŸÇÿß€åÿ≥Ÿá ÿ≤€åÿ±ÿ¥ÿ®⁄©Ÿá‚ÄåŸáÿß</option>
                               <option value="periods">ŸÖŸÇÿß€åÿ≥Ÿá ÿØŸàÿ±Ÿá‚ÄåŸáÿß€å ÿ≤ŸÖÿßŸÜ€å</option>
                           </select>
                       </div>
                       <div class="select-group">
                           <label for="comparisonMetric">ŸÖÿπ€åÿßÿ± ŸÖŸÇÿß€åÿ≥Ÿá:</label>
                           <select id="comparisonMetric">
                               <option value="uptime">ÿ¢Ÿæÿ™ÿß€åŸÖ</option>
                               <option value="response_time">ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ</option>
                               <option value="outages">ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å</option>
                               <option value="quality">ÿßŸÖÿ™€åÿßÿ≤ ⁄©€åŸÅ€åÿ™</option>
                           </select>
                       </div>
                       <button class="btn" onclick="generateComparison()">ÿß€åÿ¨ÿßÿØ ŸÖŸÇÿß€åÿ≥Ÿá</button>
                   </div>
                   <div class="charts-grid">
                       <div class="chart-container">
                           <h3 class="chart-title">üìä ŸÜŸÖŸàÿØÿßÿ± ŸÖŸÇÿß€åÿ≥Ÿá</h3>
                           <div id="comparisonChart"></div>
                       </div>
                       <div class="chart-container">
                           <h3 class="chart-title">üéØ ÿ±ÿ™ÿ®Ÿá‚Äåÿ®ŸÜÿØ€å ÿπŸÖŸÑ⁄©ÿ±ÿØ</h3>
                           <div id="rankingChart"></div>
                       </div>
                   </div>
               </div>
           </div>

           <div id="network" class="tab-content">
               <div class="charts-grid">
                   <div class="chart-container">
                       <h3 class="chart-title">üó∫Ô∏è ÿ™ŸàŸæŸàŸÑŸà⁄ò€å ÿ¥ÿ®⁄©Ÿá</h3>
                       <div id="topologyChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üìä ÿπŸÖŸÑ⁄©ÿ±ÿØ ⁄Ø€åÿ™‚ÄåŸà€å‚ÄåŸáÿß</h3>
                       <div id="gatewayChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üè¢ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ≤€åÿ±ÿ¥ÿ®⁄©Ÿá‚ÄåŸáÿß</h3>
                       <div id="subnetChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üîó ÿ™Ÿàÿ≤€åÿπ ŸÜŸàÿπ ÿØÿ≥ÿ™⁄ØÿßŸá</h3>
                       <div id="deviceTypeChart"></div>
                   </div>
               </div>
           </div>

           <div id="reports" class="tab-content">
               <div class="export-section">
                   <h3>üìã ⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™ Ÿà ÿÆÿ±Ÿàÿ¨€å</h3>
                   <p>⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™ ÿ¨ÿßŸÖÿπ Ÿà ÿ™ÿÆÿµÿµ€å ÿßÿ≤ ÿ™ÿ≠ŸÑ€åŸÑ ÿ¥ÿ®⁄©Ÿá</p>
                   <div class="export-buttons">
                       <button class="export-btn excel" onclick="exportDetailedReport()">
                           üìä ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ™ŸÅÿµ€åŸÑ€å Excel
                       </button>
                       <button class="export-btn pdf" onclick="exportSummaryPDF()">
                           üìã ÿÆŸÑÿßÿµŸá PDF
                       </button>
                       <button class="export-btn" onclick="exportDowntimeReport()">
                           ‚è∞ ⁄Øÿ≤ÿßÿ±ÿ¥ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß
                       </button>
                       <button class="export-btn" onclick="exportComparisonReport()">
                           üîÑ ⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖŸÇÿß€åÿ≥Ÿá
                       </button>
                   </div>
               </div>
           </div>

           <!-- Export Section -->
           <div class="export-section">
               <h3>üì§ ÿÆÿ±Ÿàÿ¨€å ŸÜÿ™ÿß€åÿ¨ ÿ™ÿ≠ŸÑ€åŸÑ</h3>
               <p>ÿØÿßŸÜŸÑŸàÿØ ⁄Øÿ≤ÿßÿ±ÿ¥ÿßÿ™ ÿ¨ÿßŸÖÿπ ÿØÿ± ŸÅÿ±ŸÖÿ™‚ÄåŸáÿß€å ŸÖÿÆÿ™ŸÑŸÅ</p>
               <div class="export-buttons">
                   <button class="export-btn excel" onclick="exportToExcel()">
                       üìä ⁄Øÿ≤ÿßÿ±ÿ¥ Excel
                   </button>
                   <button class="export-btn pdf" onclick="exportToPDF()">
                       üìã ⁄Øÿ≤ÿßÿ±ÿ¥ PDF
                   </button>
                   <button class="export-btn" onclick="exportToJSON()">
                       üíæ ÿØÿßÿØŸá JSON
                   </button>
                   <button class="export-btn" onclick="exportCustomReport()">
                       üé® ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ≥ŸÅÿßÿ±ÿ¥€å
                   </button>
               </div>
           </div>
       </div>
   </div>

   <!-- Live Updates Indicator -->
   <div class="live-indicator" id="liveIndicator">
       ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ≤ŸÜÿØŸá
   </div>

   <script>
       let networkData = null;
       let filteredData = null;
       let deviceStats = {};
       let downtimeAnalysis = {};
       let currentDateRange = 'all';
       let startDate = null;
       let endDate = null;
       let currentFilter = 'all';

       // Initialize when page loads
       document.addEventListener('DOMContentLoaded', function() {
           setupEventListeners();
           setupDateControls();
       });

       function setupEventListeners() {
           const uploadArea = document.getElementById('uploadArea');
           const fileInput = document.getElementById('fileInput');

           // Drag and drop
           uploadArea.addEventListener('dragover', (e) => {
               e.preventDefault();
               uploadArea.classList.add('dragover');
           });

           uploadArea.addEventListener('dragleave', () => {
               uploadArea.classList.remove('dragover');
           });

           uploadArea.addEventListener('drop', (e) => {
               e.preventDefault();
               uploadArea.classList.remove('dragover');
               const files = e.dataTransfer.files;
               if (files.length > 0) {
                   handleFile(files[0]);
               }
           });

           uploadArea.addEventListener('click', () => {
               fileInput.click();
           });

           fileInput.addEventListener('change', (e) => {
               if (e.target.files.length > 0) {
                   handleFile(e.target.files[0]);
               }
           });

           // Filter buttons
           document.querySelectorAll('.filter-btn').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                   e.target.classList.add('active');
                   currentFilter = e.target.dataset.filter;
                   filterDevices();
               });
           });

           // Search functionality
           document.getElementById('deviceSearch').addEventListener('input', (e) => {
               filterDevices(e.target.value);
           });
       }

       function setupDateControls() {
           const today = new Date();
           const thirtyDaysAgo = new Date(today.getTime() - 30 * 24 * 60 * 60 * 1000);

           document.getElementById('endDate').value = today.toISOString().split('T')[0];
           document.getElementById('startDate').value = thirtyDaysAgo.toISOString().split('T')[0];

           // Time range selector
           document.getElementById('timeRange').addEventListener('change', function(e) {
               const value = e.target.value;
               if (value !== 'custom') {
                   setQuickRange(parseInt(value));
               }
           });
       }

       function setQuickRange(days) {
           const today = new Date();
           const startDate = new Date(today.getTime() - days * 24 * 60 * 60 * 1000);

           document.getElementById('endDate').value = today.toISOString().split('T')[0];
           document.getElementById('startDate').value = startDate.toISOString().split('T')[0];

           currentDateRange = days;

           if (networkData) {
               applyDateFilter();
           }
       }

       function applyDateFilter() {
           if (!networkData) return;

           const startDateStr = document.getElementById('startDate').value;
           const endDateStr = document.getElementById('endDate').value;

           if (!startDateStr || !endDateStr) {
               alert('ŸÑÿ∑ŸÅÿß ÿ™ÿßÿ±€åÿÆ ÿ¥ÿ±Ÿàÿπ Ÿà Ÿæÿß€åÿßŸÜ ÿ±ÿß ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ');
               return;
           }

           startDate = new Date(startDateStr);
           endDate = new Date(endDateStr + 'T23:59:59');

           filteredData = networkData.filter(row => {
               if (!row['Timestamp']) return false;
               const rowDate = new Date(row['Timestamp']);
               return rowDate >= startDate && rowDate <= endDate;
           });

           if (filteredData.length === 0) {
               alert('ÿØÿ± ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å ÿßŸÜÿ™ÿÆÿßÿ®€å ÿØÿßÿØŸá‚Äåÿß€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ');
               return;
           }

           showLiveIndicator('ÿßÿπŸÖÿßŸÑ ŸÅ€åŸÑÿ™ÿ± ÿ≤ŸÖÿßŸÜ€å...');
           analyzeFilteredData();
           updateAllVisualizations();
       }

       function resetDateFilter() {
           filteredData = networkData;
           currentDateRange = 'all';

           document.getElementById('timeRange').value = 'all';

           if (networkData) {
               analyzeFilteredData();
               updateAllVisualizations();
               showLiveIndicator('ÿ®ÿßÿ≤ŸÜÿ¥ÿßŸÜ€å ŸÅ€åŸÑÿ™ÿ±Ÿáÿß');
           }
       }

       function handleFile(file) {
           if (!file.name.endsWith('.csv')) {
               alert('ŸÑÿ∑ŸÅÿß €å⁄© ŸÅÿß€åŸÑ CSV ÿßŸÜÿ™ÿÆÿßÿ® ⁄©ŸÜ€åÿØ');
               return;
           }

           document.getElementById('uploadSection').classList.add('hidden');
           document.getElementById('loading').style.display = 'block';

           const reader = new FileReader();
           reader.onload = function(e) {
               const csv = e.target.result;
               parseAndAnalyze(csv);
           };
           reader.readAsText(file);
       }

       async function loadSampleData() {
           try {
               const csvContent = await window.fs.readFile('all_history_all_20250613_074840.csv', { encoding: 'utf8' });
               document.getElementById('uploadSection').classList.add('hidden');
               document.getElementById('loading').style.display = 'block';
               parseAndAnalyze(csvContent);
           } catch (error) {
               console.log('ÿØÿßÿØŸá ŸÜŸÖŸàŸÜŸá ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™');
               alert('ÿØÿßÿØŸá ŸÜŸÖŸàŸÜŸá ÿØÿ± ÿØÿ≥ÿ™ÿ±ÿ≥ ŸÜ€åÿ≥ÿ™. ŸÑÿ∑ŸÅÿß ŸÅÿß€åŸÑ CSV ÿÆŸàÿØ ÿ±ÿß ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ⁄©ŸÜ€åÿØ.');
           }
       }

       function showDataFormat() {
           alert(`ÿ≥ÿ™ŸàŸÜ‚ÄåŸáÿß€å ŸÖŸàÿ±ÿØ ŸÜ€åÿßÿ≤ CSV:
- Device Name - ŸÜÿßŸÖ ÿØÿ≥ÿ™⁄ØÿßŸá ÿ¥ÿ®⁄©Ÿá
- IP Address - ÿ¢ÿØÿ±ÿ≥ IP ÿØÿ≥ÿ™⁄ØÿßŸá
- Type - ŸÜŸàÿπ ÿØÿ≥ÿ™⁄ØÿßŸá (PLC, Client, Gateway Ÿà ÿ∫€åÿ±Ÿá)
- Parent Gateway - ŸÜÿßŸÖ ⁄Ø€åÿ™‚ÄåŸà€å ŸÖÿ™ÿµŸÑ
- Status - Ÿàÿ∂ÿπ€åÿ™ ÿ¢ŸÜŸÑÿß€åŸÜ/ÿ¢ŸÅŸÑÿß€åŸÜ
- Response Time (ms) - ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ ÿ®Ÿá ŸÖ€åŸÑ€å‚Äåÿ´ÿßŸÜ€åŸá
- Timestamp - ÿ™ÿßÿ±€åÿÆ Ÿà ÿ≤ŸÖÿßŸÜ ÿ±⁄©Ÿàÿ±ÿØ`);
       }

       function parseAndAnalyze(csvText) {
           Papa.parse(csvText, {
               header: true,
               dynamicTyping: true,
               skipEmptyLines: true,
               complete: function(results) {
                   networkData = results.data;
                   filteredData = networkData;

                   // Clean and normalize data
                   networkData = networkData.filter(row =>
                       row['Device Name'] && row['Device Name'].trim() !== ''
                   );

                   // Convert timestamps and clean data
                   networkData.forEach(row => {
                       if (row['Timestamp']) {
                           row['Timestamp'] = new Date(row['Timestamp']);
                       }
                       if (row['Response Time (ms)']) {
                           row['Response Time (ms)'] = parseFloat(row['Response Time (ms)']) || 0;
                       }
                   });

                   filteredData = networkData;
                   analyzeFilteredData();
                   showResults();
               },
               error: function(error) {
                   console.error('ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ CSV:', error);
                   alert('ÿÆÿ∑ÿß ÿØÿ± Ÿæÿ±ÿØÿßÿ≤ÿ¥ ŸÅÿß€åŸÑ CSV');
                   resetToUpload();
               }
           });
       }

       function analyzeFilteredData() {
           if (!filteredData || filteredData.length === 0) return;

           calculateDeviceStats();
           calculateDowntimeAnalysis();
           calculateNetworkAnalysis();
       }

       function calculateDeviceStats() {
           deviceStats = {};

           filteredData.forEach(row => {
               const deviceName = row['Device Name'];
               if (!deviceStats[deviceName]) {
                   deviceStats[deviceName] = {
                       name: deviceName,
                       type: row['Type'] || 'ŸÜÿßŸÖÿ¥ÿÆÿµ',
                       ip: row['IP Address'] || 'ŸÜÿßŸÖÿ¥ÿÆÿµ',
                       gateway: row['Parent Gateway'] || 'ŸÜÿßŸÖÿ¥ÿÆÿµ',
                       totalRecords: 0,
                       onlineRecords: 0,
                       responseTimes: [],
                       lastSeen: null,
                       qualityScore: 0,
                       healthStatus: 'ŸÜÿßŸÖÿ¥ÿÆÿµ',
                       outages: [],
                       totalDowntime: 0
                   };
               }

               const stats = deviceStats[deviceName];
               stats.totalRecords++;

               if (row['Status'] && row['Status'].toLowerCase() === 'online') {
                   stats.onlineRecords++;
                   if (row['Response Time (ms)'] && row['Response Time (ms)'] > 0) {
                       stats.responseTimes.push(row['Response Time (ms)']);
                   }
               }

               if (row['Timestamp'] && (!stats.lastSeen || row['Timestamp'] > stats.lastSeen)) {
                   stats.lastSeen = row['Timestamp'];
               }
           });

           // Calculate derived metrics
           Object.values(deviceStats).forEach(stats => {
               stats.uptime = stats.totalRecords > 0 ? (stats.onlineRecords / stats.totalRecords) * 100 : 0;
               stats.avgResponseTime = stats.responseTimes.length > 0
                   ? stats.responseTimes.reduce((a, b) => a + b, 0) / stats.responseTimes.length
                   : 0;

               stats.qualityScore = calculateQualityScore(stats.uptime, stats.avgResponseTime);
               stats.healthStatus = determineHealthStatus(stats.qualityScore, stats.uptime);
           });
       }

       function calculateDowntimeAnalysis() {
           downtimeAnalysis = {
               totalOutages: 0,
               totalDowntime: 0,
               outagesByDevice: {},
               outagesByHour: Array(24).fill(0),
               outagesByDay: {},
               downtimeRecords: []
           };

           // Group data by device and sort by timestamp
           const deviceGroups = {};
           filteredData.forEach(row => {
               const device = row['Device Name'];
               if (!deviceGroups[device]) {
                   deviceGroups[device] = [];
               }
               deviceGroups[device].push(row);
           });

           // Analyze outages for each device
           Object.keys(deviceGroups).forEach(deviceName => {
               const deviceData = deviceGroups[deviceName].sort((a, b) =>
                   new Date(a.Timestamp) - new Date(b.Timestamp)
               );

               let currentOutage = null;
               let deviceOutageCount = 0;
               let deviceDowntime = 0;

               deviceData.forEach((row, index) => {
                   const status = row['Status']?.toLowerCase();
                   const timestamp = new Date(row['Timestamp']);

                   if (status === 'offline' && !currentOutage) {
                       // Start of outage
                       currentOutage = {
                           device: deviceName,
                           startTime: timestamp,
                           endTime: null,
                           duration: 0
                       };
                   } else if (status === 'online' && currentOutage) {
                       // End of outage
                       currentOutage.endTime = timestamp;
                       currentOutage.duration = (timestamp - currentOutage.startTime) / (1000 * 60); // minutes

                       downtimeAnalysis.downtimeRecords.push({...currentOutage});
                       downtimeAnalysis.totalOutages++;
                       downtimeAnalysis.totalDowntime += currentOutage.duration;

                       deviceOutageCount++;
                       deviceDowntime += currentOutage.duration;

                       // Count by hour
                       const hour = currentOutage.startTime.getHours();
                       downtimeAnalysis.outagesByHour[hour]++;

                       // Count by day
                       const day = currentOutage.startTime.toDateString();
                       downtimeAnalysis.outagesByDay[day] = (downtimeAnalysis.outagesByDay[day] || 0) + 1;

                       currentOutage = null;
                   }
               });

               downtimeAnalysis.outagesByDevice[deviceName] = {
                   count: deviceOutageCount,
                   totalDowntime: deviceDowntime
               };
           });
       }

       function calculateNetworkAnalysis() {
           // Implementation for network analysis (gateways, subnets, etc.)
           // Similar to original but working with filteredData
       }

       function calculateQualityScore(uptime, avgResponseTime) {
           let score = 0;
           score += Math.min(uptime * 0.4, 40);

           if (avgResponseTime <= 50) score += 35;
           else if (avgResponseTime <= 100) score += 30;
           else if (avgResponseTime <= 200) score += 20;
           else if (avgResponseTime <= 500) score += 10;
           else score += 5;

           if (avgResponseTime > 0) {
               const stability = Math.max(0, 25 - (avgResponseTime / 20));
               score += stability;
           }

           return Math.round(score);
       }

       function determineHealthStatus(qualityScore, uptime) {
           if (qualityScore >= 90 && uptime >= 95) return 'excellent';
           if (qualityScore >= 75 && uptime >= 85) return 'good';
           if (qualityScore >= 60 && uptime >= 70) return 'fair';
           return 'poor';
       }

       function showResults() {
           document.getElementById('loading').style.display = 'none';
           document.getElementById('results').classList.remove('hidden');

           updateAllVisualizations();
           showLiveIndicator('ÿ™ÿ≠ŸÑ€åŸÑ ⁄©ÿßŸÖŸÑ ÿ¥ÿØ');
       }

       function updateAllVisualizations() {
           createSummaryCards();
           createStatsCards();
           createAllCharts();
           createDeviceCards();
           createDowntimeTable();
       }

       function createSummaryCards() {
           const totalDevices = Object.keys(deviceStats).length;
           const totalRecords = filteredData.length;
           const onlineRecords = filteredData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           const overallUptime = totalRecords > 0 ? (onlineRecords / totalRecords) * 100 : 0;

           const startDateStr = startDate ? startDate.toLocaleDateString('fa-IR') : 'ÿ¥ÿ±Ÿàÿπ ÿØÿßÿØŸá‚ÄåŸáÿß';
           const endDateStr = endDate ? endDate.toLocaleDateString('fa-IR') : 'Ÿæÿß€åÿßŸÜ ÿØÿßÿØŸá‚ÄåŸáÿß';

           const summaryHTML = `
               <div class="summary-item">
                   <div class="summary-value">${totalRecords.toLocaleString()}</div>
                   <div class="summary-label">⁄©ŸÑ ÿ±⁄©Ÿàÿ±ÿØŸáÿß€å ÿ®ÿßÿ≤Ÿá</div>
               </div>
               <div class="summary-item">
                   <div class="summary-value">${downtimeAnalysis.totalOutages}</div>
                   <div class="summary-label">⁄©ŸÑ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß</div>
               </div>
               <div class="summary-item">
                   <div class="summary-value">${Math.round(downtimeAnalysis.totalDowntime)} ÿØŸÇ€åŸÇŸá</div>
                   <div class="summary-label">⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å</div>
               </div>
               <div class="summary-item">
                   <div class="summary-value">${overallUptime.toFixed(1)}%</div>
                   <div class="summary-label">ÿ¢Ÿæÿ™ÿß€åŸÖ ⁄©ŸÑ€å ÿ®ÿßÿ≤Ÿá</div>
               </div>
               <div class="summary-item">
                   <div class="summary-value">${startDateStr}</div>
                   <div class="summary-label">ÿ™ÿßÿ±€åÿÆ ÿ¥ÿ±Ÿàÿπ</div>
               </div>
               <div class="summary-item">
                   <div class="summary-value">${endDateStr}</div>
                   <div class="summary-label">ÿ™ÿßÿ±€åÿÆ Ÿæÿß€åÿßŸÜ</div>
               </div>
           `;

           document.getElementById('summaryGrid').innerHTML = summaryHTML;
       }

       function createStatsCards() {
           const totalDevices = Object.keys(deviceStats).length;
           const totalRecords = filteredData.length;
           const onlineRecords = filteredData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           const overallUptime = totalRecords > 0 ? (onlineRecords / totalRecords) * 100 : 0;
           const avgResponseTime = calculateOverallAvgResponseTime();
           const healthyDevices = getHealthyDeviceCount();

           const statsHTML = `
               <div class="stat-card">
                   <div class="stat-value">${totalDevices}</div>
                   <div class="stat-label">⁄©ŸÑ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${totalRecords.toLocaleString()}</div>
                   <div class="stat-label">⁄©ŸÑ ÿ±⁄©Ÿàÿ±ÿØŸáÿß</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${overallUptime.toFixed(1)}%</div>
                   <div class="stat-label">ÿ¢Ÿæÿ™ÿß€åŸÖ ⁄©ŸÑ€å</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${avgResponseTime.toFixed(0)} ms</div>
                   <div class="stat-label">ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${downtimeAnalysis.totalOutages}</div>
                   <div class="stat-label">⁄©ŸÑ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${healthyDevices}</div>
                   <div class="stat-label">ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å ÿ≥ÿßŸÑŸÖ</div>
               </div>
           `;

           document.getElementById('statsGrid').innerHTML = statsHTML;
       }

       function calculateOverallAvgResponseTime() {
           const responseTimes = filteredData
               .filter(row => row['Response Time (ms)'] && row['Response Time (ms)'] > 0)
               .map(row => row['Response Time (ms)']);

           return responseTimes.length > 0
               ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
               : 0;
       }

       function getHealthyDeviceCount() {
           return Object.values(deviceStats).filter(stats =>
               stats.healthStatus === 'excellent' || stats.healthStatus === 'good'
           ).length;
       }

       function createAllCharts() {
           createStatusChart();
           createResponseTimeChart();
           createHourlyChart();
           createHeatmapChart();
           createDailyStatusChart();
           createDailyUptimeChart();
           createDailyOutagesChart();
           createDowntimeCharts();
           createNetworkCharts();
       }

       function createStatusChart() {
           const onlineCount = filteredData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           const offlineCount = filteredData.length - onlineCount;

           const data = [{
               values: [onlineCount, offlineCount],
               labels: ['ÿ¢ŸÜŸÑÿß€åŸÜ', 'ÿ¢ŸÅŸÑÿß€åŸÜ'],
               type: 'pie',
               marker: {
                   colors: ['#06d6a0', '#ef476f']
               },
               hole: 0.4,
               textinfo: 'label+percent',
               textposition: 'outside'
           }];

           const layout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 },
               font: { family: 'Segoe UI' }
           };

           Plotly.newPlot('statusChart', data, layout, {responsive: true});
       }

       function createDailyStatusChart() {
        const dailyData = {};
        
        filteredData.forEach(row => {
            if (!row['Timestamp']) return;
            
            const date = new Date(row['Timestamp']).toDateString();
            if (!dailyData[date]) {
                dailyData[date] = { total: 0, online: 0 };
            }
            
            dailyData[date].total++;
            if (row['Status'] && row['Status'].toLowerCase() === 'online') {
                dailyData[date].online++;
            }
        });
    
        const dates = Object.keys(dailyData).sort((a, b) => new Date(a) - new Date(b));
        const uptimePercentages = dates.map(date => {
            const data = dailyData[date];
            return data.total > 0 ? (data.online / data.total) * 100 : 0;
        });
    
        const trace = {
            x: dates.map(date => new Date(date).toLocaleDateString('fa-IR')),
            y: uptimePercentages,
            type: 'scatter',
            mode: 'lines+markers',
            line: { color: '#667eea', width: 3 },
            marker: { size: 8, color: '#667eea' },
            fill: 'tonexty',
            fillcolor: 'rgba(102, 126, 234, 0.1)',
            name: 'ÿ¢Ÿæÿ™ÿß€åŸÖ ÿ±Ÿàÿ≤ÿßŸÜŸá'
        };
    
        const layout = {
            xaxis: { title: 'ÿ™ÿßÿ±€åÿÆ' },
            yaxis: { title: 'ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ', range: [0, 100] },
            height: 350,
            margin: { t: 20, b: 50, l: 50, r: 20 }
        };
    
        Plotly.newPlot('dailyStatusChart', [trace], layout, {responsive: true});
    }

   function createDailyUptimeChart() {
       // Calculate uptime for each device by day
       const deviceDailyUptime = {};

       Object.keys(deviceStats).slice(0, 10).forEach(deviceName => {
           const deviceData = filteredData.filter(row => row['Device Name'] === deviceName);
           const dailyData = {};

           deviceData.forEach(row => {
               if (!row['Timestamp']) return;

               const date = new Date(row['Timestamp']).toDateString();
               if (!dailyData[date]) {
                   dailyData[date] = { total: 0, online: 0 };
               }

               dailyData[date].total++;
               if (row['Status'] && row['Status'].toLowerCase() === 'online') {
                   dailyData[date].online++;
               }
           });

           deviceDailyUptime[deviceName] = dailyData;
       });

       const dates = [...new Set(filteredData.map(row =>
           row['Timestamp'] ? new Date(row['Timestamp']).toDateString() : null
       ).filter(Boolean))].sort((a, b) => new Date(a) - new Date(b));

       const traces = Object.keys(deviceDailyUptime).map((deviceName, index) => {
           const colors = ['#667eea', '#06d6a0', '#f78c6b', '#ef476f', '#118ab2', '#764ba2'];
           const uptimes = dates.map(date => {
               const dayData = deviceDailyUptime[deviceName][date];
               return dayData && dayData.total > 0 ? (dayData.online / dayData.total) * 100 : 0;
           });

           return {
               x: dates.map(date => new Date(date).toLocaleDateString('fa-IR')),
               y: uptimes,
               type: 'scatter',
               mode: 'lines+markers',
               name: deviceName,
               line: { color: colors[index % colors.length] },
               marker: { size: 6 }
           };
       });

       const layout = {
           xaxis: { title: 'ÿ™ÿßÿ±€åÿÆ' },
           yaxis: { title: 'ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ', range: [0, 100] },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 },
           showlegend: true
       };

       Plotly.newPlot('dailyUptimeChart', traces, layout, {responsive: true});
   }

   function createDailyOutagesChart() {
       const outagesByDay = downtimeAnalysis.outagesByDay;
       const dates = Object.keys(outagesByDay).sort((a, b) => new Date(a) - new Date(b));
       const counts = dates.map(date => outagesByDay[date]);

       const data = [{
           x: dates.map(date => new Date(date).toLocaleDateString('fa-IR')),
           y: counts,
           type: 'bar',
           marker: {
               color: counts.map(count => {
                   if (count >= 10) return '#ef476f';
                   if (count >= 5) return '#f78c6b';
                   return '#06d6a0';
               })
           },
           name: 'ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å'
       }];

       const layout = {
           xaxis: { title: 'ÿ™ÿßÿ±€åÿÆ' },
           yaxis: { title: 'ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å' },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('dailyOutagesChart', data, layout, {responsive: true});
   }

   function createWeeklyComparisonChart() {
       // Compare current week with previous weeks
       const weeklyData = {};

       filteredData.forEach(row => {
           if (!row['Timestamp']) return;

           const date = new Date(row['Timestamp']);
           const weekStart = new Date(date.setDate(date.getDate() - date.getDay()));
           const weekKey = weekStart.toDateString();

           if (!weeklyData[weekKey]) {
               weeklyData[weekKey] = { total: 0, online: 0 };
           }

           weeklyData[weekKey].total++;
           if (row['Status'] && row['Status'].toLowerCase() === 'online') {
               weeklyData[weekKey].online++;
           }
       });

       const weeks = Object.keys(weeklyData).sort((a, b) => new Date(a) - new Date(b));
       const weeklyUptimes = weeks.map(week => {
           const data = weeklyData[week];
           return data.total > 0 ? (data.online / data.total) * 100 : 0;
       });

       const data = [{
           x: weeks.map(week => `ŸáŸÅÿ™Ÿá ${new Date(week).toLocaleDateString('fa-IR')}`),
           y: weeklyUptimes,
           type: 'bar',
           marker: {
               color: weeklyUptimes.map(uptime => {
                   if (uptime >= 95) return '#06d6a0';
                   if (uptime >= 85) return '#28a745';
                   if (uptime >= 70) return '#f78c6b';
                   return '#ef476f';
               })
           }
       }];

       const layout = {
           xaxis: { title: 'ŸáŸÅÿ™Ÿá' },
           yaxis: { title: 'ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ', range: [0, 100] },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('weeklyComparisonChart', data, layout, {responsive: true});
   }

   function createDowntimeCharts() {
       // Downtime duration distribution
       const durations = downtimeAnalysis.downtimeRecords.map(record => record.duration);

       const durationData = [{
           x: durations,
           type: 'histogram',
           nbinsx: 20,
           marker: { color: '#ef476f', opacity: 0.7 },
           name: 'ÿ™Ÿàÿ≤€åÿπ ŸÖÿØÿ™ ŸÇÿ∑ÿπ€å'
       }];

       const durationLayout = {
           xaxis: { title: 'ŸÖÿØÿ™ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)' },
           yaxis: { title: 'ŸÅÿ±ÿßŸàÿßŸÜ€å' },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('downtimeDurationChart', durationData, durationLayout, {responsive: true});

       // Hourly outage pattern
       const hourlyData = [{
           x: Array.from({length: 24}, (_, i) => i),
           y: downtimeAnalysis.outagesByHour,
           type: 'bar',
           marker: { color: '#f78c6b' },
           name: 'ŸÇÿ∑ÿπ€å‚ÄåŸáÿß€å ÿ≥ÿßÿπÿ™€å'
       }];

       const hourlyLayout = {
           xaxis: { title: 'ÿ≥ÿßÿπÿ™ ÿ±Ÿàÿ≤' },
           yaxis: { title: 'ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å' },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('downtimeHourlyChart', hourlyData, hourlyLayout, {responsive: true});

       // Top devices with most downtime
       const deviceDowntimes = Object.entries(downtimeAnalysis.outagesByDevice)
           .sort((a, b) => b[1].totalDowntime - a[1].totalDowntime)
           .slice(0, 10);

       const topDevicesData = [{
           x: deviceDowntimes.map(([device, _]) => device),
           y: deviceDowntimes.map(([_, data]) => data.totalDowntime),
           type: 'bar',
           marker: { color: '#ef476f' },
           name: 'ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)'
       }];

       const topDevicesLayout = {
           xaxis: { title: 'ÿØÿ≥ÿ™⁄ØÿßŸá', tickangle: -45 },
           yaxis: { title: '⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)' },
           height: 350,
           margin: { t: 20, b: 100, l: 50, r: 20 }
       };

       Plotly.newPlot('topDowntimeDevicesChart', topDevicesData, topDevicesLayout, {responsive: true});
   }

   function createResponseTimeChart() {
       // Group by hour and calculate average response time
       const hourlyData = {};

       filteredData.forEach(row => {
           if (row['Timestamp'] && row['Response Time (ms)'] && row['Response Time (ms)'] > 0) {
               const hour = new Date(row['Timestamp']).getHours();
               if (!hourlyData[hour]) {
                   hourlyData[hour] = [];
               }
               hourlyData[hour].push(row['Response Time (ms)']);
           }
       });

       const hours = [];
       const avgResponseTimes = [];

       for (let hour = 0; hour < 24; hour++) {
           hours.push(hour);
           if (hourlyData[hour] && hourlyData[hour].length > 0) {
               const avg = hourlyData[hour].reduce((a, b) => a + b, 0) / hourlyData[hour].length;
               avgResponseTimes.push(avg);
           } else {
               avgResponseTimes.push(0);
           }
       }

       const data = [{
           x: hours,
           y: avgResponseTimes,
           type: 'scatter',
           mode: 'lines+markers',
           line: { color: '#667eea', width: 3 },
           marker: { size: 8, color: '#667eea' },
           fill: 'tonexty',
           fillcolor: 'rgba(102, 126, 234, 0.1)',
           name: 'ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ'
       }];

       const layout = {
           xaxis: { title: 'ÿ≥ÿßÿπÿ™ ÿ±Ÿàÿ≤' },
           yaxis: { title: 'ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ (ms)' },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('responseTimeChart', data, layout, {responsive: true});
   }

   function createHourlyChart() {
       // Calculate uptime percentage by hour
       const hourlyUptime = {};

       for (let hour = 0; hour < 24; hour++) {
           const hourData = filteredData.filter(row =>
               row['Timestamp'] && new Date(row['Timestamp']).getHours() === hour
           );
           const onlineCount = hourData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;

           hourlyUptime[hour] = hourData.length > 0 ? (onlineCount / hourData.length) * 100 : 0;
       }

       const hours = Object.keys(hourlyUptime).map(Number);
       const uptimes = Object.values(hourlyUptime);

       const data = [{
           x: hours,
           y: uptimes,
           type: 'bar',
           marker: {
               color: uptimes.map(uptime =>
                   uptime >= 90 ? '#06d6a0' :
                   uptime >= 70 ? '#f78c6b' : '#ef476f'
               )
           },
           name: 'ÿ¢Ÿæÿ™ÿß€åŸÖ ÿ≥ÿßÿπÿ™€å'
       }];

       const layout = {
           xaxis: { title: 'ÿ≥ÿßÿπÿ™ ÿ±Ÿàÿ≤' },
           yaxis: { title: 'ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ' },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('hourlyChart', data, layout, {responsive: true});
   }

   function createHeatmapChart() {
       // Create device-hour heatmap
       const devices = Object.keys(deviceStats).slice(0, 15);
       const hours = Array.from({length: 24}, (_, i) => i);

       const heatmapData = devices.map(device => {
           return hours.map(hour => {
               const deviceHourData = filteredData.filter(row =>
                   row['Device Name'] === device &&
                   row['Timestamp'] &&
                   new Date(row['Timestamp']).getHours() === hour
               );

               if (deviceHourData.length === 0) return 0;

               const onlineCount = deviceHourData.filter(row =>
                   row['Status'] && row['Status'].toLowerCase() === 'online'
               ).length;

               return (onlineCount / deviceHourData.length) * 100;
           });
       });

       const data = [{
           z: heatmapData,
           x: hours,
           y: devices,
           type: 'heatmap',
           colorscale: 'RdYlGn',
           showscale: true,
           hoverongaps: false
       }];

       const layout = {
           xaxis: { title: 'ÿ≥ÿßÿπÿ™ ÿ±Ÿàÿ≤' },
           yaxis: { title: 'ÿØÿ≥ÿ™⁄ØÿßŸá' },
           height: 350,
           margin: { t: 20, b: 50, l: 150, r: 20 }
       };

       Plotly.newPlot('heatmapChart', data, layout, {responsive: true});
   }

   function createNetworkCharts() {
       // Gateway performance chart
       const gateways = [...new Set(filteredData.map(row => row['Parent Gateway']).filter(Boolean))];
       const gatewayUptimes = gateways.map(gateway => {
           const gatewayData = filteredData.filter(row => row['Parent Gateway'] === gateway);
           const onlineCount = gatewayData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           return gatewayData.length > 0 ? (onlineCount / gatewayData.length) * 100 : 0;
       });

       const gatewayData = [{
           x: gateways,
           y: gatewayUptimes,
           type: 'bar',
           marker: {
               color: gatewayUptimes.map(uptime =>
                   uptime >= 90 ? '#06d6a0' :
                   uptime >= 70 ? '#f78c6b' : '#ef476f'
               )
           },
           name: 'ÿ¢Ÿæÿ™ÿß€åŸÖ ⁄Ø€åÿ™‚ÄåŸà€å'
       }];

       const gatewayLayout = {
           xaxis: { title: '⁄Ø€åÿ™‚ÄåŸà€å' },
           yaxis: { title: 'ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ' },
           height: 350,
           margin: { t: 20, b: 50, l: 50, r: 20 }
       };

       Plotly.newPlot('gatewayChart', gatewayData, gatewayLayout, {responsive: true});

       // Device type distribution
       const deviceTypes = {};
       filteredData.forEach(row => {
           const type = row['Type'] || 'ŸÜÿßŸÖÿ¥ÿÆÿµ';
           deviceTypes[type] = (deviceTypes[type] || 0) + 1;
       });

       const typeData = [{
           labels: Object.keys(deviceTypes),
           values: Object.values(deviceTypes),
           type: 'pie',
           marker: {
               colors: ['#667eea', '#06d6a0', '#f78c6b', '#ef476f', '#118ab2']
           }
       }];

       const typeLayout = {
           showlegend: true,
           height: 350,
           margin: { t: 0, b: 0, l: 0, r: 0 }
       };

       Plotly.newPlot('deviceTypeChart', typeData, typeLayout, {responsive: true});

       // Subnet analysis
       const subnets = [...new Set(filteredData.map(row => {
           const ip = row['IP Address'];
           return ip ? ip.split('.').slice(0, 3).join('.') + '.0/24' : null;
       }))].filter(Boolean).slice(0, 10);

       const subnetUptimes = subnets.map(subnet => {
           const subnetPrefix = subnet.split('/')[0].split('.').slice(0, 3).join('.');
           const subnetData = filteredData.filter(row =>
               row['IP Address']?.startsWith(subnetPrefix)
           );
           const onlineCount = subnetData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           return subnetData.length > 0 ? (onlineCount / subnetData.length) * 100 : 0;
       });

       const subnetData = [{
           x: subnets,
           y: subnetUptimes,
           type: 'bar',
           marker: {
               color: subnetUptimes.map(uptime =>
                   uptime >= 90 ? '#06d6a0' :
                   uptime >= 70 ? '#f78c6b' : '#ef476f'
               )
           }
       }];

       const subnetLayout = {
           xaxis: { title: 'ÿ≤€åÿ±ÿ¥ÿ®⁄©Ÿá', tickangle: -45 },
           yaxis: { title: 'ÿØÿ±ÿµÿØ ÿ¢Ÿæÿ™ÿß€åŸÖ' },
           height: 350,
           margin: { t: 20, b: 100, l: 50, r: 20 }
       };

       Plotly.newPlot('subnetChart', subnetData, subnetLayout, {responsive: true});

       // Network topology (simplified)
       createTopologyChart();
   }

   function createTopologyChart() {
       const gateways = [...new Set(filteredData.map(row => row['Parent Gateway']).filter(Boolean))];
       const devices = [...new Set(filteredData.map(row => row['Device Name']))];

       // Create nodes for network topology
       const gatewayNodes = gateways.slice(0, 5).map((gw, i) => ({
           x: Math.cos(2 * Math.PI * i / Math.min(5, gateways.length)) * 2,
           y: Math.sin(2 * Math.PI * i / Math.min(5, gateways.length)) * 2,
           text: gw,
           type: 'gateway'
       }));

       const deviceNodes = devices.slice(0, 20).map((device, i) => {
           const deviceData = filteredData.find(row => row['Device Name'] === device);
           const gateway = deviceData ? deviceData['Parent Gateway'] : null;
           const gatewayIndex = gateways.indexOf(gateway);

           if (gatewayIndex !== -1 && gatewayIndex < 5) {
               const angle = (2 * Math.PI * i / 20) + (gatewayIndex * 0.5);
               const radius = 1 + Math.random() * 0.5;
               return {
                   x: gatewayNodes[gatewayIndex].x + Math.cos(angle) * radius,
                   y: gatewayNodes[gatewayIndex].y + Math.sin(angle) * radius,
                   text: device,
                   type: deviceData ? deviceData['Type'] : 'ŸÜÿßŸÖÿ¥ÿÆÿµ'
               };
           }
           return {
               x: Math.random() * 6 - 3,
               y: Math.random() * 6 - 3,
               text: device,
               type: 'ŸÜÿßŸÖÿ¥ÿÆÿµ'
           };
       });

       // Create edges
       const edgeTrace = {
           x: [],
           y: [],
           mode: 'lines',
           line: { color: '#cbd5e1', width: 1 },
           showlegend: false,
           hoverinfo: 'none'
       };

       devices.slice(0, 20).forEach(device => {
           const deviceData = filteredData.find(row => row['Device Name'] === device);
           if (deviceData && deviceData['Parent Gateway']) {
               const gatewayIndex = gateways.indexOf(deviceData['Parent Gateway']);
               const deviceIndex = devices.slice(0, 20).indexOf(device);

               if (gatewayIndex !== -1 && gatewayIndex < 5 && deviceIndex !== -1) {
                   edgeTrace.x.push(gatewayNodes[gatewayIndex].x, deviceNodes[deviceIndex].x, null);
                   edgeTrace.y.push(gatewayNodes[gatewayIndex].y, deviceNodes[deviceIndex].y, null);
               }
           }
       });

       const traces = [
           edgeTrace,
           {
               x: gatewayNodes.map(n => n.x),
               y: gatewayNodes.map(n => n.y),
               mode: 'markers+text',
               marker: { size: 15, color: '#ef476f', symbol: 'square' },
               text: gatewayNodes.map(n => n.text),
               textposition: 'middle center',
               name: '⁄Ø€åÿ™‚ÄåŸà€å‚ÄåŸáÿß'
           },
           {
               x: deviceNodes.map(n => n.x),
               y: deviceNodes.map(n => n.y),
               mode: 'markers',
               marker: {
                   size: 8,
                   color: deviceNodes.map(n => {
                       switch(n.type) {
                           case 'PLC': return '#118ab2';
                           case 'Client': return '#06d6a0';
                           case 'Gateway': return '#ef476f';
                           default: return '#667eea';
                       }
                   })
               },
               text: deviceNodes.map(n => n.text),
               name: 'ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß'
           }
       ];

       const layout = {
           showlegend: true,
           xaxis: { showgrid: false, showticklabels: false, zeroline: false },
           yaxis: { showgrid: false, showticklabels: false, zeroline: false },
           height: 350,
           margin: { t: 20, b: 20, l: 20, r: 20 }
       };

       Plotly.newPlot('topologyChart', traces, layout, {responsive: true});
   }

   function createDeviceCards() {
       const deviceArray = Object.values(deviceStats)
           .sort((a, b) => b.uptime - a.uptime);

       const cardsHTML = deviceArray.map(device => {
           const outageInfo = downtimeAnalysis.outagesByDevice[device.name] || { count: 0, totalDowntime: 0 };

           return `
               <div class="device-card ${device.healthStatus}" data-device="${device.name}" data-health="${device.healthStatus}">
                   <div class="device-header">
                       <div class="device-name">${device.name}</div>
                       <div class="device-status ${device.uptime > 80 ? 'status-online' : 'status-offline'}">
                           ${device.type}
                       </div>
                   </div>
                   <div class="progress-bar">
                       <div class="progress-fill progress-${device.healthStatus}"
                            style="width: ${device.uptime}%"></div>
                   </div>
                   <p style="margin: 5px 0; font-size: 0.9rem;">
                       <span class="performance-indicator indicator-${device.healthStatus}"></span>
                       ÿ¢Ÿæÿ™ÿß€åŸÖ: ${device.uptime.toFixed(1)}% | ÿßŸÖÿ™€åÿßÿ≤ ⁄©€åŸÅ€åÿ™: ${device.qualityScore}
                   </p>
                   <div class="device-metrics">
                       <div class="metric tooltip" data-tooltip="ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ ÿØÿ± ÿ≠ÿßŸÑÿ™ ÿ¢ŸÜŸÑÿß€åŸÜ">
                           <div class="metric-value">${device.avgResponseTime.toFixed(0)}</div>
                           <div class="metric-label">ŸÖÿ™Ÿàÿ≥ÿ∑ Ÿæÿßÿ≥ÿÆ (ms)</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="⁄©ŸÑ ÿ±⁄©Ÿàÿ±ÿØŸáÿß ÿØÿ± ÿ®ÿßÿ≤Ÿá ÿßŸÜÿ™ÿÆÿßÿ®€å">
                           <div class="metric-value">${device.totalRecords}</div>
                           <div class="metric-label">⁄©ŸÑ ÿ±⁄©Ÿàÿ±ÿØŸáÿß</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß">
                           <div class="metric-value">${outageInfo.count}</div>
                           <div class="metric-label">ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="ŸÖÿ¨ŸÖŸàÿπ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å">
                           <div class="metric-value">${Math.round(outageInfo.totalDowntime)}</div>
                           <div class="metric-label">ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="⁄Ø€åÿ™‚ÄåŸà€å ŸÖÿ™ÿµŸÑ">
                           <div class="metric-value">${device.gateway}</div>
                           <div class="metric-label">⁄Ø€åÿ™‚ÄåŸà€å</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="ÿ¢ÿØÿ±ÿ≥ IP ÿØÿ≥ÿ™⁄ØÿßŸá">
                           <div class="metric-value">${device.ip}</div>
                           <div class="metric-label">ÿ¢ÿØÿ±ÿ≥ IP</div>
                       </div>
                   </div>
               </div>
           `;
       }).join('');

       document.getElementById('deviceGrid').innerHTML = cardsHTML;
   }

   function createDowntimeTable() {
       const sortedOutages = downtimeAnalysis.downtimeRecords
           .sort((a, b) => b.duration - a.duration)
           .slice(0, 50); // Show top 50 outages

       const tableHTML = sortedOutages.map(outage => {
           const durationClass = outage.duration > 60 ? 'duration-long' :
                                 outage.duration > 15 ? 'duration-medium' : 'duration-short';

           const impact = outage.duration > 60 ? 'ÿ®ÿ≠ÿ±ÿßŸÜ€å' :
                         outage.duration > 15 ? 'ŸÖÿ™Ÿàÿ≥ÿ∑' : '⁄©ŸÖ';

           return `
               <tr>
                   <td>${outage.device}</td>
                   <td>${outage.startTime.toLocaleString('fa-IR')}</td>
                   <td>${outage.endTime ? outage.endTime.toLocaleString('fa-IR') : 'ÿØÿ± ÿ≠ÿßŸÑ ŸÇÿ∑ÿπ€å'}</td>
                   <td class="downtime-duration ${durationClass}">${Math.round(outage.duration)} ÿØŸÇ€åŸÇŸá</td>
                   <td>${outage.duration > 60 ? 'ÿ∑ŸàŸÑÿßŸÜ€å' : outage.duration > 15 ? 'ŸÖÿ™Ÿàÿ≥ÿ∑' : '⁄©Ÿàÿ™ÿßŸá'}</td>
                   <td>${impact}</td>
               </tr>
           `;
       }).join('');

       document.getElementById('downtimeTableBody').innerHTML = tableHTML;
   }

   function generateComparison() {
       const comparisonType = document.getElementById('comparisonType').value;
       const comparisonMetric = document.getElementById('comparisonMetric').value;

       // Implementation for comparison charts based on selected type and metric
       // This would create dynamic comparison visualizations
       showLiveIndicator('ÿß€åÿ¨ÿßÿØ ŸÖŸÇÿß€åÿ≥Ÿá...');
   }

   function filterDevices(searchTerm = '') {
       const deviceCards = document.querySelectorAll('.device-card');

       deviceCards.forEach(card => {
           const deviceName = card.dataset.device.toLowerCase();
           const healthStatus = card.dataset.health;

           const matchesSearch = searchTerm === '' || deviceName.includes(searchTerm.toLowerCase());
           const matchesFilter = currentFilter === 'all' ||
                                 healthStatus === currentFilter ||
                                 (currentFilter === 'online' && healthStatus !== 'poor') ||
                                 (currentFilter === 'offline' && healthStatus === 'poor');

           if (matchesSearch && matchesFilter) {
               card.style.display = 'block';
           } else {
               card.style.display = 'none';
           }
       });
   }

   function showTab(tabName, clickedElement = null) {
   // Hide all tab contents
   const tabContents = document.querySelectorAll('.tab-content');
   tabContents.forEach(content => content.classList.remove('active'));

   // Remove active class from all tabs
   const tabs = document.querySelectorAll('.tab');
   tabs.forEach(tab => tab.classList.remove('active'));

   // Show selected tab content
   const targetTab = document.getElementById(tabName);
   if (targetTab) {
       targetTab.classList.add('active');
   }

   // Add active class to clicked tab
   if (clickedElement) {
       clickedElement.classList.add('active');
   } else {
       // Fallback: find and activate the corresponding tab button
       tabs.forEach(tab => {
           const onclickAttr = tab.getAttribute('onclick');
           if (onclickAttr && onclickAttr.includes(`'${tabName}'`)) {
               tab.classList.add('active');
           }
       });
   }

   // Redraw charts to ensure proper sizing after tab switch
   setTimeout(() => {
       const charts = [
           'statusChart', 
           'responseTimeChart', 
           'hourlyChart', 
           'heatmapChart',
           'dailyStatusChart', 
           'dailyUptimeChart', 
           'dailyOutagesChart', 
           'weeklyComparisonChart',
           'downtimeDurationChart', 
           'downtimeHourlyChart', 
           'topDowntimeDevicesChart',
           'comparisonChart', 
           'rankingChart', 
           'topologyChart', 
           'gatewayChart',
           'subnetChart', 
           'deviceTypeChart'
       ];

       charts.forEach(chartId => {
           const element = document.getElementById(chartId);
           if (element && element.children.length > 0) {
               try {
                   Plotly.Plots.resize(element);
               } catch (error) {
                   console.log(`Chart ${chartId} resize failed:`, error);
               }
           }
       });
   }, 100);

   // Log tab change for debugging
   console.log(`Switched to tab: ${tabName}`);
}

   function showLiveIndicator(message = 'ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å ÿ≤ŸÜÿØŸá') {
       const indicator = document.getElementById('liveIndicator');
        indicator.textContent = message;
       indicator.classList.add('show');

       setTimeout(() => {
           indicator.classList.remove('show');
       }, 3000);
   }

   function resetToUpload() {
       document.getElementById('uploadSection').classList.remove('hidden');
       document.getElementById('loading').style.display = 'none';
       document.getElementById('results').classList.add('hidden');
   }

   // Export functions
   function exportToExcel() {
       if (!filteredData) {
           alert('ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ÿÆÿ±Ÿàÿ¨€å ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™');
           return;
       }

       // Create comprehensive CSV content
       const deviceHeaders = ['ŸÜÿßŸÖ ÿØÿ≥ÿ™⁄ØÿßŸá', 'ŸÜŸàÿπ', 'ÿ¢ÿØÿ±ÿ≥ IP', '⁄Ø€åÿ™‚ÄåŸà€å', 'ÿ¢Ÿæÿ™ÿß€åŸÖ (%)', 'ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ', 'ÿßŸÖÿ™€åÿßÿ≤ ⁄©€åŸÅ€åÿ™', 'Ÿàÿ∂ÿπ€åÿ™ ÿ≥ŸÑÿßŸÖÿ™', 'ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å', '⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)'];
       const deviceRows = Object.values(deviceStats).map(device => {
           const outageInfo = downtimeAnalysis.outagesByDevice[device.name] || { count: 0, totalDowntime: 0 };
           return [
               device.name,
               device.type,
               device.ip,
               device.gateway,
               device.uptime.toFixed(2),
               device.avgResponseTime.toFixed(2),
               device.qualityScore,
               device.healthStatus,
               outageInfo.count,
               Math.round(outageInfo.totalDowntime)
           ].join(',');
       });

       const deviceCsv = [deviceHeaders.join(','), ...deviceRows].join('\n');

       // Outage details
       const outageHeaders = ['ÿØÿ≥ÿ™⁄ØÿßŸá', 'ÿ¥ÿ±Ÿàÿπ ŸÇÿ∑ÿπ€å', 'Ÿæÿß€åÿßŸÜ ŸÇÿ∑ÿπ€å', 'ŸÖÿØÿ™ (ÿØŸÇ€åŸÇŸá)', 'ŸÜŸàÿπ'];
       const outageRows = downtimeAnalysis.downtimeRecords.map(outage => [
           outage.device,
           outage.startTime.toLocaleString('fa-IR'),
           outage.endTime ? outage.endTime.toLocaleString('fa-IR') : 'ÿØÿ± ÿ≠ÿßŸÑ ŸÇÿ∑ÿπ€å',
           Math.round(outage.duration),
           outage.duration > 60 ? 'ÿ∑ŸàŸÑÿßŸÜ€å' : outage.duration > 15 ? 'ŸÖÿ™Ÿàÿ≥ÿ∑' : '⁄©Ÿàÿ™ÿßŸá'
       ].join(','));

       const outageCsv = [outageHeaders.join(','), ...outageRows].join('\n');

       // Combined report
       const fullReport = `⁄Øÿ≤ÿßÿ±ÿ¥ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß\n${deviceCsv}\n\nÿ¨ÿ≤ÿ¶€åÿßÿ™ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n${outageCsv}`;

       downloadFile(fullReport, `⁄Øÿ≤ÿßÿ±ÿ¥_ÿ¥ÿ®⁄©Ÿá_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ Excel ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function exportToPDF() {
       alert('ŸÇÿßÿ®ŸÑ€åÿ™ ÿÆÿ±Ÿàÿ¨€å PDF ÿ®ÿß ⁄©ÿ™ÿßÿ®ÿÆÿßŸÜŸá PDF Ÿæ€åÿßÿØŸá‚Äåÿ≥ÿßÿ≤€å ÿÆŸàÿßŸáÿØ ÿ¥ÿØ');
   }

   function exportToJSON() {
       if (!filteredData) {
           alert('ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ÿÆÿ±Ÿàÿ¨€å ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™');
           return;
       }

       const exportData = {
           summary: {
               totalDevices: Object.keys(deviceStats).length,
               totalRecords: filteredData.length,
               dateRange: {
                   start: startDate ? startDate.toISOString() : 'ÿ¥ÿ±Ÿàÿπ ÿØÿßÿØŸá‚ÄåŸáÿß',
                   end: endDate ? endDate.toISOString() : 'Ÿæÿß€åÿßŸÜ ÿØÿßÿØŸá‚ÄåŸáÿß'
               },
               overallUptime: (filteredData.filter(row => row['Status']?.toLowerCase() === 'online').length / filteredData.length * 100).toFixed(2),
               totalOutages: downtimeAnalysis.totalOutages,
               totalDowntime: Math.round(downtimeAnalysis.totalDowntime),
               exportDate: new Date().toISOString()
           },
           deviceStats: deviceStats,
           downtimeAnalysis: downtimeAnalysis,
           filteredDataSample: filteredData.slice(0, 100) // Sample of filtered data
       };

       const jsonContent = JSON.stringify(exportData, null, 2);
       downloadFile(jsonContent, `ÿØÿßÿØŸá_ÿ¥ÿ®⁄©Ÿá_${new Date().toLocaleDateString('fa-IR')}.json`, 'application/json');
       showLiveIndicator('ÿØÿßÿØŸá JSON ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function exportDetailedReport() {
       if (!filteredData) {
           alert('ÿØÿßÿØŸá‚Äåÿß€å ÿ®ÿ±ÿß€å ÿÆÿ±Ÿàÿ¨€å ŸÖŸàÿ¨ŸàÿØ ŸÜ€åÿ≥ÿ™');
           return;
       }

       // Create detailed Excel-compatible report
       let report = '⁄Øÿ≤ÿßÿ±ÿ¥ ÿ™ŸÅÿµ€åŸÑ€å ÿ™ÿ≠ŸÑ€åŸÑ ÿ¥ÿ®⁄©Ÿá\n';
       report += `ÿ™ÿßÿ±€åÿÆ ÿ™ŸàŸÑ€åÿØ: ${new Date().toLocaleString('fa-IR')}\n`;
       report += `ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å: ${startDate ? startDate.toLocaleDateString('fa-IR') : 'ÿ¥ÿ±Ÿàÿπ'} ÿ™ÿß ${endDate ? endDate.toLocaleDateString('fa-IR') : 'Ÿæÿß€åÿßŸÜ'}\n\n`;

       // Summary section
       report += 'ÿÆŸÑÿßÿµŸá ⁄©ŸÑ€å\n';
       report += `⁄©ŸÑ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß,${Object.keys(deviceStats).length}\n`;
       report += `⁄©ŸÑ ÿ±⁄©Ÿàÿ±ÿØŸáÿß,${filteredData.length}\n`;
       report += `⁄©ŸÑ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß,${downtimeAnalysis.totalOutages}\n`;
       report += `⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá),${Math.round(downtimeAnalysis.totalDowntime)}\n\n`;

       // Device performance section
       report += 'ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß\n';
       report += 'ŸÜÿßŸÖ ÿØÿ≥ÿ™⁄ØÿßŸá,ŸÜŸàÿπ,ÿ¢Ÿæÿ™ÿß€åŸÖ (%),ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ,ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å,⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá),ÿßŸÖÿ™€åÿßÿ≤ ⁄©€åŸÅ€åÿ™\n';

       Object.values(deviceStats).forEach(device => {
           const outageInfo = downtimeAnalysis.outagesByDevice[device.name] || { count: 0, totalDowntime: 0 };
           report += `${device.name},${device.type},${device.uptime.toFixed(2)},${device.avgResponseTime.toFixed(2)},${outageInfo.count},${Math.round(outageInfo.totalDowntime)},${device.qualityScore}\n`;
       });

       report += '\nÿßŸÑ⁄ØŸà€å ÿ≥ÿßÿπÿ™€å ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n';
       report += 'ÿ≥ÿßÿπÿ™,ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å\n';
       downtimeAnalysis.outagesByHour.forEach((count, hour) => {
           report += `${hour},${count}\n`;
       });

       downloadFile(report, `⁄Øÿ≤ÿßÿ±ÿ¥_ÿ™ŸÅÿµ€åŸÑ€å_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ ÿ™ŸÅÿµ€åŸÑ€å ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function exportSummaryPDF() {
       alert('ÿÆÿ±Ÿàÿ¨€å ÿÆŸÑÿßÿµŸá PDF ÿØÿ± ÿ≠ÿßŸÑ ÿ™Ÿàÿ≥ÿπŸá ÿßÿ≥ÿ™');
   }

   function exportDowntimeReport() {
       if (!downtimeAnalysis.downtimeRecords || downtimeAnalysis.downtimeRecords.length === 0) {
           alert('ŸÇÿ∑ÿπ€å‚Äåÿß€å ÿØÿ± ÿ®ÿßÿ≤Ÿá ÿßŸÜÿ™ÿÆÿßÿ®€å €åÿßŸÅÿ™ ŸÜÿ¥ÿØ');
           return;
       }

       let report = '⁄Øÿ≤ÿßÿ±ÿ¥ ÿ™ÿÆÿµÿµ€å ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n';
       report += `ÿ™ÿßÿ±€åÿÆ ÿ™ŸàŸÑ€åÿØ: ${new Date().toLocaleString('fa-IR')}\n`;
       report += `ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å: ${startDate ? startDate.toLocaleDateString('fa-IR') : 'ÿ¥ÿ±Ÿàÿπ'} ÿ™ÿß ${endDate ? endDate.toLocaleDateString('fa-IR') : 'Ÿæÿß€åÿßŸÜ'}\n\n`;

       report += 'ÿ¢ŸÖÿßÿ± ⁄©ŸÑ€å\n';
       report += `⁄©ŸÑ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß,${downtimeAnalysis.totalOutages}\n`;
       report += `⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá),${Math.round(downtimeAnalysis.totalDowntime)}\n`;
       report += `ŸÖÿ™Ÿàÿ≥ÿ∑ ŸÖÿØÿ™ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá),${(downtimeAnalysis.totalDowntime / downtimeAnalysis.totalOutages).toFixed(2)}\n\n`;

       report += 'ÿ¨ÿ≤ÿ¶€åÿßÿ™ ŸáŸÖŸá ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n';
       report += 'ÿØÿ≥ÿ™⁄ØÿßŸá,ÿ¥ÿ±Ÿàÿπ ŸÇÿ∑ÿπ€å,Ÿæÿß€åÿßŸÜ ŸÇÿ∑ÿπ€å,ŸÖÿØÿ™ (ÿØŸÇ€åŸÇŸá),ŸÜŸàÿπ ŸÇÿ∑ÿπ€å\n';

       downtimeAnalysis.downtimeRecords
           .sort((a, b) => b.duration - a.duration)
           .forEach(outage => {
               const type = outage.duration > 60 ? 'ÿ∑ŸàŸÑÿßŸÜ€å' : outage.duration > 15 ? 'ŸÖÿ™Ÿàÿ≥ÿ∑' : '⁄©Ÿàÿ™ÿßŸá';
               report += `${outage.device},${outage.startTime.toLocaleString('fa-IR')},${outage.endTime ? outage.endTime.toLocaleString('fa-IR') : 'ÿØÿ± ÿ≠ÿßŸÑ ŸÇÿ∑ÿπ€å'},${Math.round(outage.duration)},${type}\n`;
           });

       report += '\nÿ¢ŸÖÿßÿ± ŸÇÿ∑ÿπ€å ÿ®Ÿá ÿ™ŸÅ⁄©€å⁄© ÿØÿ≥ÿ™⁄ØÿßŸá\n';
       report += 'ÿØÿ≥ÿ™⁄ØÿßŸá,ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å,⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá),ŸÖÿ™Ÿàÿ≥ÿ∑ ŸÖÿØÿ™ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)\n';

       Object.entries(downtimeAnalysis.outagesByDevice)
           .sort((a, b) => b[1].totalDowntime - a[1].totalDowntime)
           .forEach(([device, data]) => {
               const avgDuration = data.count > 0 ? (data.totalDowntime / data.count).toFixed(2) : 0;
               report += `${device},${data.count},${Math.round(data.totalDowntime)},${avgDuration}\n`;
           });

       downloadFile(report, `⁄Øÿ≤ÿßÿ±ÿ¥_ŸÇÿ∑ÿπ€å_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ ŸÇÿ∑ÿπ€å ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function exportComparisonReport() {
       alert('⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖŸÇÿß€åÿ≥Ÿá ÿØÿ± ÿ≠ÿßŸÑ ÿ™Ÿàÿ≥ÿπŸá ÿßÿ≥ÿ™');
   }

   function exportCustomReport() {
       const options = prompt(`ÿßŸÜÿ™ÿÆÿßÿ® ŸÜŸàÿπ ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ≥ŸÅÿßÿ±ÿ¥€å:
1 - ⁄Øÿ≤ÿßÿ±ÿ¥ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿ®ÿ±ÿ™ÿ±
2 - ⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖÿ¥⁄©ŸÑÿßÿ™
3 - ⁄Øÿ≤ÿßÿ±ÿ¥ ÿ±ŸàŸÜÿØŸáÿß
4 - ⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßŸÖŸÑ

ÿ¥ŸÖÿßÿ±Ÿá ŸÖŸàÿ±ÿØ ŸÜÿ∏ÿ± ÿ±ÿß Ÿàÿßÿ±ÿØ ⁄©ŸÜ€åÿØ (1-4):`);

       switch(options) {
           case '1':
               generateTopPerformersReport();
               break;
           case '2':
               generateIssuesReport();
               break;
           case '3':
               generateTrendsReport();
               break;
           case '4':
               generateCompleteReport();
               break;
           default:
               alert('ÿßŸÜÿ™ÿÆÿßÿ® ŸÜÿßŸÖÿπÿ™ÿ®ÿ±');
       }
   }

   function generateTopPerformersReport() {
       const topDevices = Object.values(deviceStats)
           .filter(device => device.healthStatus === 'excellent' || device.healthStatus === 'good')
           .sort((a, b) => b.uptime - a.uptime)
           .slice(0, 10);

       let report = '⁄Øÿ≤ÿßÿ±ÿ¥ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å ÿ®ÿ±ÿ™ÿ±\n';
       report += `ÿ™ÿßÿ±€åÿÆ: ${new Date().toLocaleString('fa-IR')}\n\n`;
       report += 'ÿ±ÿ™ÿ®Ÿá,ŸÜÿßŸÖ ÿØÿ≥ÿ™⁄ØÿßŸá,ÿ¢Ÿæÿ™ÿß€åŸÖ (%),ÿßŸÖÿ™€åÿßÿ≤ ⁄©€åŸÅ€åÿ™,ŸÖÿ™Ÿàÿ≥ÿ∑ ÿ≤ŸÖÿßŸÜ Ÿæÿßÿ≥ÿÆ\n';

       topDevices.forEach((device, index) => {
           report += `${index + 1},${device.name},${device.uptime.toFixed(2)},${device.qualityScore},${device.avgResponseTime.toFixed(2)}\n`;
       });

       downloadFile(report, `⁄Øÿ≤ÿßÿ±ÿ¥_ÿ®ÿ±ÿ™ÿ±€åŸÜ_ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å ÿ®ÿ±ÿ™ÿ± ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function generateIssuesReport() {
       const problematicDevices = Object.values(deviceStats)
           .filter(device => device.healthStatus === 'poor' || device.healthStatus === 'fair')
           .sort((a, b) => a.uptime - b.uptime);

       let report = '⁄Øÿ≤ÿßÿ±ÿ¥ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å ŸÖÿ¥⁄©ŸÑ‚ÄåÿØÿßÿ±\n';
       report += `ÿ™ÿßÿ±€åÿÆ: ${new Date().toLocaleString('fa-IR')}\n\n`;
       report += 'ŸÜÿßŸÖ ÿØÿ≥ÿ™⁄ØÿßŸá,ÿ¢Ÿæÿ™ÿß€åŸÖ (%),ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å,⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá),Ÿàÿ∂ÿπ€åÿ™,ÿßŸàŸÑŸà€åÿ™ ÿ±ŸÅÿπ\n';

       problematicDevices.forEach(device => {
           const outageInfo = downtimeAnalysis.outagesByDevice[device.name] || { count: 0, totalDowntime: 0 };
           const priority = device.uptime < 50 ? 'ÿ®ÿ≠ÿ±ÿßŸÜ€å' : device.uptime < 80 ? 'ÿ®ÿßŸÑÿß' : 'ŸÖÿ™Ÿàÿ≥ÿ∑';
           report += `${device.name},${device.uptime.toFixed(2)},${outageInfo.count},${Math.round(outageInfo.totalDowntime)},${device.healthStatus},${priority}\n`;
       });

       downloadFile(report, `⁄Øÿ≤ÿßÿ±ÿ¥_ŸÖÿ¥⁄©ŸÑÿßÿ™_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ ŸÖÿ¥⁄©ŸÑÿßÿ™ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function generateTrendsReport() {
       let report = '⁄Øÿ≤ÿßÿ±ÿ¥ ÿ±ŸàŸÜÿØŸáÿß Ÿà ÿßŸÑ⁄ØŸàŸáÿß\n';
       report += `ÿ™ÿßÿ±€åÿÆ: ${new Date().toLocaleString('fa-IR')}\n\n`;

       // Hourly pattern analysis
       report += 'ÿßŸÑ⁄ØŸà€å ÿ≥ÿßÿπÿ™€å ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n';
       report += 'ÿ≥ÿßÿπÿ™,ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å,ÿØÿ±ÿµÿØ ⁄©ŸÑ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n';
       const totalHourlyOutages = downtimeAnalysis.outagesByHour.reduce((a, b) => a + b, 0);

       downtimeAnalysis.outagesByHour.forEach((count, hour) => {
           const percentage = totalHourlyOutages > 0 ? (count / totalHourlyOutages * 100).toFixed(2) : 0;
           report += `${hour},${count},${percentage}\n`;
       });

       // Daily pattern analysis
       report += '\nÿßŸÑ⁄ØŸà€å ÿ±Ÿàÿ≤ÿßŸÜŸá ŸÇÿ∑ÿπ€å‚ÄåŸáÿß\n';
       report += 'ÿ™ÿßÿ±€åÿÆ,ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å\n';
       Object.entries(downtimeAnalysis.outagesByDay)
           .sort((a, b) => new Date(a[0]) - new Date(b[0]))
           .forEach(([date, count]) => {
               report += `${new Date(date).toLocaleDateString('fa-IR')},${count}\n`;
           });

       downloadFile(report, `⁄Øÿ≤ÿßÿ±ÿ¥_ÿ±ŸàŸÜÿØŸáÿß_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ ÿ±ŸàŸÜÿØŸáÿß ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function generateCompleteReport() {
       let report = '⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßŸÖŸÑ ÿ™ÿ≠ŸÑ€åŸÑ ÿ¥ÿ®⁄©Ÿá\n';
       report += `ÿ™ÿßÿ±€åÿÆ ÿ™ŸàŸÑ€åÿØ: ${new Date().toLocaleString('fa-IR')}\n`;
       report += `ÿ®ÿßÿ≤Ÿá ÿ≤ŸÖÿßŸÜ€å: ${startDate ? startDate.toLocaleDateString('fa-IR') : 'ÿ¥ÿ±Ÿàÿπ'} ÿ™ÿß ${endDate ? endDate.toLocaleDateString('fa-IR') : 'Ÿæÿß€åÿßŸÜ'}\n\n`;

       // Executive summary
       report += '=== ÿÆŸÑÿßÿµŸá ÿßÿ¨ÿ±ÿß€å€å ===\n';
       const healthyCount = Object.values(deviceStats).filter(d => d.healthStatus === 'excellent' || d.healthStatus === 'good').length;
       const overallUptime = (filteredData.filter(row => row['Status']?.toLowerCase() === 'online').length / filteredData.length * 100);

       report += `⁄©ŸÑ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß: ${Object.keys(deviceStats).length}\n`;
       report += `ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å ÿ≥ÿßŸÑŸÖ: ${healthyCount} (${(healthyCount / Object.keys(deviceStats).length * 100).toFixed(1)}%)\n`;
       report += `ÿ¢Ÿæÿ™ÿß€åŸÖ ⁄©ŸÑ€å: ${overallUptime.toFixed(2)}%\n`;
       report += `⁄©ŸÑ ŸÇÿ∑ÿπ€å‚ÄåŸáÿß: ${downtimeAnalysis.totalOutages}\n`;
       report += `⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å: ${Math.round(downtimeAnalysis.totalDowntime)} ÿØŸÇ€åŸÇŸá\n\n`;

       // Add all sections from other reports
       report += '=== ÿ¨ÿ≤ÿ¶€åÿßÿ™ ÿπŸÖŸÑ⁄©ÿ±ÿØ ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß ===\n';
       report += 'ŸÜÿßŸÖ ÿØÿ≥ÿ™⁄ØÿßŸá,ŸÜŸàÿπ,ÿ¢Ÿæÿ™ÿß€åŸÖ (%),ÿßŸÖÿ™€åÿßÿ≤ ⁄©€åŸÅ€åÿ™,ÿ™ÿπÿØÿßÿØ ŸÇÿ∑ÿπ€å,⁄©ŸÑ ÿ≤ŸÖÿßŸÜ ŸÇÿ∑ÿπ€å (ÿØŸÇ€åŸÇŸá)\n';
       Object.values(deviceStats).forEach(device => {
           const outageInfo = downtimeAnalysis.outagesByDevice[device.name] || { count: 0, totalDowntime: 0 };
           report += `${device.name},${device.type},${device.uptime.toFixed(2)},${device.qualityScore},${outageInfo.count},${Math.round(outageInfo.totalDowntime)}\n`;
       });

       report += '\n=== ÿ™Ÿàÿµ€åŸá‚ÄåŸáÿß ===\n';
       const criticalDevices = Object.values(deviceStats).filter(d => d.uptime < 70);
       if (criticalDevices.length > 0) {
           report += `${criticalDevices.length} ÿØÿ≥ÿ™⁄ØÿßŸá ŸÜ€åÿßÿ≤ ÿ®Ÿá ÿ™Ÿàÿ¨Ÿá ŸÅŸàÿ±€å ÿØÿßÿ±ŸÜÿØ\n`;
           criticalDevices.forEach(device => {
               report += `- ${device.name}: ÿ¢Ÿæÿ™ÿß€åŸÖ ${device.uptime.toFixed(1)}%\n`;
           });
       } else {
           report += 'ŸáŸÖŸá ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß ÿØÿ± Ÿàÿ∂ÿπ€åÿ™ ŸÇÿßÿ®ŸÑ ŸÇÿ®ŸàŸÑ€å Ÿáÿ≥ÿ™ŸÜÿØ\n';
       }

       downloadFile(report, `⁄Øÿ≤ÿßÿ±ÿ¥_⁄©ÿßŸÖŸÑ_${new Date().toLocaleDateString('fa-IR')}.csv`, 'text/csv');
       showLiveIndicator('⁄Øÿ≤ÿßÿ±ÿ¥ ⁄©ÿßŸÖŸÑ ÿß€åÿ¨ÿßÿØ ÿ¥ÿØ');
   }

   function downloadFile(content, filename, mimeType) {
       // Add BOM for proper UTF-8 display in Excel
       const BOM = '\uFEFF';
       const blob = new Blob([BOM + content], { type: mimeType });
       const url = URL.createObjectURL(blob);
       const link = document.createElement('a');
       link.href = url;
       link.download = filename;
       document.body.appendChild(link);
       link.click();
       document.body.removeChild(link);
       URL.revokeObjectURL(url);
   }

   // Auto-load sample data if available
   window.addEventListener('load', () => {
       if (window.fs && typeof window.fs.readFile === 'function') {
           setTimeout(() => {
               loadSampleData();
           }, 1000);
       }
   });

   // Real-time updates simulation
   setInterval(() => {
       if (filteredData && filteredData.length > 0 && Math.random() > 0.98) {
           showLiveIndicator('ÿ®ÿ±ÿ±ÿ≥€å ÿ®Ÿá‚Äåÿ±Ÿàÿ≤ÿ±ÿ≥ÿßŸÜ€å‚ÄåŸáÿß...');
       }
   }, 15000);

</script>
</body>
</html>
