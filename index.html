<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üöÄ Advanced Network Analyzer Dashboard</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --secondary: #764ba2;
            --success: #06d6a0;
            --danger: #ef476f;
            --warning: #f78c6b;
            --info: #118ab2;
            --dark: #073b4c;
            --light: #f8f9fa;
            --gradient-primary: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --gradient-success: linear-gradient(135deg, #06d6a0 0%, #118ab2 100%);
            --glass-bg: rgba(255, 255, 255, 0.25);
            --glass-border: rgba(255, 255, 255, 0.18);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--gradient-primary);
            min-height: 100vh;
            color: var(--dark);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 800;
            background: var(--gradient-primary);
            background-clip: text;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 10px;
        }

        .upload-section {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 15px;
            padding: 30px;
            margin-bottom: 30px;
            text-align: center;
            border: 2px dashed var(--primary);
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            background: rgba(255, 255, 255, 0.95);
            transform: translateY(-2px);
        }

        .upload-area {
            padding: 40px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .upload-area.dragover {
            background: rgba(6, 214, 160, 0.1);
            border-color: var(--success);
        }

        .file-input {
            display: none;
        }

        .btn {
            background: var(--gradient-primary);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn.success {
            background: var(--gradient-success);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--gradient-primary);
        }

        .stat-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 15px 40px rgba(0,0,0,0.15);
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 800;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .stat-label {
            color: #6c757d;
            font-weight: 500;
        }

        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            min-height: 400px;
        }

        .chart-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--dark);
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #f1f3f4;
        }

        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .device-card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
            border-left: 4px solid var(--primary);
        }

        .device-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
        }

        .device-card.excellent { border-left-color: var(--success); }
        .device-card.good { border-left-color: #28a745; }
        .device-card.fair { border-left-color: var(--warning); }
        .device-card.poor { border-left-color: var(--danger); }

        .device-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .device-name {
            font-weight: 700;
            color: var(--dark);
        }

        .device-status {
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 600;
        }

        .status-online {
            background: rgba(6, 214, 160, 0.1);
            color: var(--success);
        }

        .status-offline {
            background: rgba(239, 71, 111, 0.1);
            color: var(--danger);
        }

        .device-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .metric {
            text-align: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .metric-value {
            font-size: 1.2rem;
            font-weight: 700;
            color: var(--primary);
        }

        .metric-label {
            font-size: 0.8rem;
            color: #6c757d;
            margin-top: 5px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            transition: width 0.8s ease;
            border-radius: 4px;
        }

        .progress-excellent { background: var(--gradient-success); }
        .progress-good { background: linear-gradient(90deg, #28a745, #20c997); }
        .progress-fair { background: linear-gradient(90deg, #ffc107, #fd7e14); }
        .progress-poor { background: linear-gradient(90deg, #fd7e14, #dc3545); }

        .loading {
            display: none;
            text-align: center;
            padding: 50px;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        .alert {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .alert-success {
            background: rgba(6, 214, 160, 0.1);
            color: var(--success);
            border: 1px solid rgba(6, 214, 160, 0.3);
        }

        .alert-danger {
            background: rgba(239, 71, 111, 0.1);
            color: var(--danger);
            border: 1px solid rgba(239, 71, 111, 0.3);
        }

        .tabs {
            display: flex;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 5px;
            margin-bottom: 20px;
        }

        .tab {
            flex: 1;
            padding: 12px 20px;
            text-align: center;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }
        .tab.active {
            background: var(--gradient-primary);
            color: white;
       }

       .tab-content {
           display: none;
       }

       .tab-content.active {
           display: block;
       }

       .recommendations-section {
           background: rgba(255, 255, 255, 0.95);
           border-radius: 15px;
           padding: 25px;
           margin-top: 30px;
           box-shadow: 0 10px 30px rgba(0,0,0,0.1);
       }

       .recommendations-title {
           font-size: 1.5rem;
           font-weight: 700;
           color: var(--dark);
           margin-bottom: 20px;
           display: flex;
           align-items: center;
           gap: 10px;
       }

       .recommendation-category {
           margin-bottom: 20px;
       }

       .category-title {
           font-size: 1.2rem;
           font-weight: 600;
           margin-bottom: 10px;
           display: flex;
           align-items: center;
           gap: 8px;
       }

       .recommendation-item {
           background: #f8f9fa;
           border-radius: 8px;
           padding: 15px;
           margin-bottom: 10px;
           border-left: 4px solid #6c757d;
           transition: all 0.3s ease;
       }

       .recommendation-item:hover {
           transform: translateX(5px);
           box-shadow: 0 5px 15px rgba(0,0,0,0.1);
       }

       .recommendation-item.critical {
           border-left-color: var(--danger);
           background: rgba(239, 71, 111, 0.05);
       }

       .recommendation-item.high {
           border-left-color: var(--warning);
           background: rgba(247, 140, 107, 0.05);
       }

       .recommendation-item.medium {
           border-left-color: #ffc107;
           background: rgba(255, 193, 7, 0.05);
       }

       .recommendation-item.low {
           border-left-color: var(--success);
           background: rgba(6, 214, 160, 0.05);
       }

       .recommendation-device {
           font-weight: 700;
           color: var(--dark);
       }

       .recommendation-text {
           margin-top: 5px;
           color: #495057;
       }

       .recommendation-issue {
           font-size: 0.9rem;
           color: #6c757d;
           margin-top: 3px;
       }

       .export-section {
           background: rgba(255, 255, 255, 0.95);
           border-radius: 15px;
           padding: 25px;
           margin-top: 30px;
           text-align: center;
           box-shadow: 0 10px 30px rgba(0,0,0,0.1);
       }

       .export-buttons {
           display: flex;
           gap: 15px;
           justify-content: center;
           flex-wrap: wrap;
           margin-top: 20px;
       }

       .export-btn {
           background: var(--gradient-primary);
           color: white;
           border: none;
           padding: 12px 25px;
           border-radius: 25px;
           font-weight: 600;
           cursor: pointer;
           transition: all 0.3s ease;
           text-decoration: none;
           display: inline-flex;
           align-items: center;
           gap: 8px;
       }

       .export-btn:hover {
           transform: translateY(-2px);
           box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
       }

       .export-btn.excel {
           background: linear-gradient(135deg, #28a745, #20c997);
       }

       .export-btn.pdf {
           background: linear-gradient(135deg, #dc3545, #e55353);
       }

       .export-btn.json {
           background: linear-gradient(135deg, #6f42c1, #8b5fbf);
       }

       .footer {
           background: rgba(255, 255, 255, 0.9);
           border-radius: 15px;
           padding: 20px;
           margin-top: 30px;
           text-align: center;
           color: #6c757d;
       }

       .performance-indicator {
           display: inline-block;
           width: 12px;
           height: 12px;
           border-radius: 50%;
           margin-right: 8px;
       }

       .indicator-excellent { background-color: var(--success); }
       .indicator-good { background-color: #28a745; }
       .indicator-fair { background-color: var(--warning); }
       .indicator-poor { background-color: var(--danger); }

       @media (max-width: 768px) {
           .charts-grid, .stats-grid {
               grid-template-columns: 1fr;
           }

           .header h1 {
               font-size: 2rem;
           }

           .device-metrics {
               grid-template-columns: 1fr;
           }

           .tabs {
               flex-direction: column;
           }

           .tab {
               margin-bottom: 5px;
           }

           .export-buttons {
               flex-direction: column;
               align-items: center;
           }
       }

       /* Advanced animations */
       @keyframes fadeInUp {
           from {
               opacity: 0;
               transform: translate3d(0, 40px, 0);
           }
           to {
               opacity: 1;
               transform: translate3d(0, 0, 0);
           }
       }

       .chart-container, .device-card, .stat-card {
           animation: fadeInUp 0.6s ease-out;
       }

       .chart-container:nth-child(1) { animation-delay: 0.1s; }
       .chart-container:nth-child(2) { animation-delay: 0.2s; }
       .chart-container:nth-child(3) { animation-delay: 0.3s; }
       .chart-container:nth-child(4) { animation-delay: 0.4s; }

       /* Tooltip styles */
       .tooltip {
           position: relative;
           cursor: help;
       }

       .tooltip::after {
           content: attr(data-tooltip);
           position: absolute;
           bottom: 125%;
           left: 50%;
           transform: translateX(-50%);
           background: var(--dark);
           color: white;
           padding: 8px 12px;
           border-radius: 6px;
           font-size: 0.8rem;
           white-space: nowrap;
           opacity: 0;
           visibility: hidden;
           transition: all 0.3s ease;
           z-index: 1000;
       }

       .tooltip:hover::after {
           opacity: 1;
           visibility: visible;
       }

       /* Enhanced button styles */
       .btn-group {
           display: flex;
           gap: 10px;
           justify-content: center;
           margin: 20px 0;
       }

       .btn-secondary {
           background: linear-gradient(135deg, #6c757d, #868e96);
       }

       .btn-info {
           background: linear-gradient(135deg, #17a2b8, #20c997);
       }

       /* Status badges */
       .status-badge {
           display: inline-block;
           padding: 4px 8px;
           border-radius: 12px;
           font-size: 0.75rem;
           font-weight: 600;
           text-transform: uppercase;
       }

       .status-critical {
           background: rgba(239, 71, 111, 0.1);
           color: var(--danger);
       }

       .status-warning {
           background: rgba(247, 140, 107, 0.1);
           color: var(--warning);
       }

       .status-success {
           background: rgba(6, 214, 160, 0.1);
           color: var(--success);
       }

       .status-info {
           background: rgba(17, 138, 178, 0.1);
           color: var(--info);
       }

       /* Network topology styles */
       .topology-legend {
           background: #f8f9fa;
           padding: 15px;
           border-radius: 8px;
           margin-top: 15px;
       }

       .legend-item {
           display: inline-flex;
           align-items: center;
           margin-right: 20px;
           margin-bottom: 5px;
       }

       .legend-color {
           width: 16px;
           height: 16px;
           border-radius: 3px;
           margin-right: 8px;
       }

       .legend-gateway { background-color: #ef476f; }
       .legend-plc { background-color: #118ab2; }
       .legend-client { background-color: #06d6a0; }

       /* Enhanced search and filter */
       .search-container {
           background: rgba(255, 255, 255, 0.9);
           border-radius: 10px;
           padding: 20px;
           margin-bottom: 20px;
       }

       .search-input {
           width: 100%;
           max-width: 400px;
           padding: 12px 20px;
           border: 2px solid #e9ecef;
           border-radius: 25px;
           font-size: 1rem;
           outline: none;
           transition: all 0.3s ease;
       }

       .search-input:focus {
           border-color: var(--primary);
           box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
       }

       .filter-buttons {
           display: flex;
           gap: 10px;
           margin-top: 15px;
           flex-wrap: wrap;
       }

       .filter-btn {
           background: #f8f9fa;
           border: 1px solid #dee2e6;
           color: #495057;
           padding: 8px 16px;
           border-radius: 20px;
           cursor: pointer;
           transition: all 0.3s ease;
           font-size: 0.9rem;
       }

       .filter-btn:hover,
       .filter-btn.active {
           background: var(--primary);
           color: white;
           border-color: var(--primary);
       }

       /* Real-time updates indicator */
       .live-indicator {
           position: fixed;
           top: 20px;
           right: 20px;
           background: var(--success);
           color: white;
           padding: 8px 16px;
           border-radius: 20px;
           font-size: 0.8rem;
           font-weight: 600;
           z-index: 1000;
           opacity: 0;
           transition: all 0.3s ease;
       }

       .live-indicator.show {
           opacity: 1;
       }

       .live-indicator::before {
           content: '‚óè';
           margin-right: 8px;
           animation: pulse 2s infinite;
       }

       @keyframes pulse {
           0%, 100% { opacity: 1; }
           50% { opacity: 0.5; }
       }
   </style>
</head>
<body>
   <div class="container">
       <!-- Header -->
       <div class="header">
           <h1>üöÄ Advanced Network Performance Analyzer</h1>
           <p>Comprehensive network monitoring and analysis dashboard</p>
       </div>

       <!-- Upload Section -->
       <div class="upload-section" id="uploadSection">
           <div class="upload-area" id="uploadArea">
               <h3>üìÅ Upload Your Network Data</h3>
               <p>Drag and drop your CSV file here or click to select</p>
               <input type="file" id="fileInput" class="file-input" accept=".csv">
               <br><br>
               <button class="btn" onclick="document.getElementById('fileInput').click()">
                   Choose CSV File
               </button>
               <div class="btn-group" style="margin-top: 15px;">
                   <button class="btn btn-secondary" onclick="loadSampleData()">
                       üìä Load Sample Data
                   </button>
                   <button class="btn btn-info" onclick="showDataFormat()">
                       ‚ùì Data Format Help
                   </button>
               </div>
           </div>
       </div>

       <!-- Loading -->
       <div class="loading" id="loading">
           <div class="loading-spinner"></div>
           <p>Analyzing your network data...</p>
       </div>

       <!-- Results Section -->
       <div id="results" class="hidden">
           <!-- Search and Filter -->
           <div class="search-container">
               <input type="text" class="search-input" placeholder="üîç Search devices..." id="deviceSearch">
               <div class="filter-buttons">
                   <button class="filter-btn active" data-filter="all">All Devices</button>
                   <button class="filter-btn" data-filter="excellent">Excellent</button>
                   <button class="filter-btn" data-filter="good">Good</button>
                   <button class="filter-btn" data-filter="fair">Fair</button>
                   <button class="filter-btn" data-filter="poor">Poor</button>
               </div>
           </div>

           <!-- Stats Cards -->
           <div class="stats-grid" id="statsGrid">
               <!-- Stats will be populated here -->
           </div>

           <!-- Tabs -->
           <div class="tabs">
               <div class="tab active" onclick="showTab('overview')">üìä Overview</div>
               <div class="tab" onclick="showTab('devices')">üñ•Ô∏è Devices</div>
               <div class="tab" onclick="showTab('performance')">üìà Performance</div>
               <div class="tab" onclick="showTab('network')">üåê Network</div>
               <div class="tab" onclick="showTab('predictions')">üîÆ Predictions</div>
               <div class="tab" onclick="showTab('anomalies')">üö® Anomalies</div>
           </div>

           <!-- Tab Contents -->
           <div id="overview" class="tab-content active">
               <div class="charts-grid">
                   <div class="chart-container">
                       <h3 class="chart-title">üîÑ Device Status Distribution</h3>
                       <div id="statusChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">‚è±Ô∏è Response Time Trends</h3>
                       <div id="responseTimeChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üïí Hourly Performance Patterns</h3>
                       <div id="hourlyChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üå°Ô∏è Performance Heatmap</h3>
                       <div id="heatmapChart"></div>
                   </div>
               </div>
           </div>

           <div id="devices" class="tab-content">
               <div class="device-grid" id="deviceGrid">
                   <!-- Device cards will be populated here -->
               </div>
           </div>

           <div id="performance" class="tab-content">
               <div class="charts-grid">
                   <div class="chart-container">
                       <h3 class="chart-title">üìä Response Time Distribution</h3>
                       <div id="distributionChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üìà Gateway Performance</h3>
                       <div id="gatewayChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üéØ Quality Score Analysis</h3>
                       <div id="qualityChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">‚ö° MTBF vs MTTR Analysis</h3>
                       <div id="reliabilityChart"></div>
                   </div>
               </div>
           </div>

           <div id="network" class="tab-content">
               <div class="charts-grid">
                   <div class="chart-container">
                       <h3 class="chart-title">üó∫Ô∏è Network Topology</h3>
                       <div id="topologyChart"></div>
                       <div class="topology-legend">
                           <div class="legend-item">
                               <div class="legend-color legend-gateway"></div>
                               <span>Gateways</span>
                           </div>
                           <div class="legend-item">
                               <div class="legend-color legend-plc"></div>
                               <span>PLCs</span>
                           </div>
                           <div class="legend-item">
                               <div class="legend-color legend-client"></div>
                               <span>Clients</span>
                           </div>
                       </div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üîó Connection Analysis</h3>
                       <div id="connectionChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üè¢ Subnet Performance</h3>
                       <div id="subnetChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üì° Gateway Load Distribution</h3>
                       <div id="loadChart"></div>
                   </div>
               </div>
           </div>

           <div id="predictions" class="tab-content">
               <div class="charts-grid">
                   <div class="chart-container">
                       <h3 class="chart-title">üîÆ 7-Day Uptime Prediction</h3>
                       <div id="uptimePredictionChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üìà Response Time Forecast</h3>
                       <div id="responseForecastChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">‚ö†Ô∏è Risk Assessment</h3>
                       <div id="riskChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üîß Maintenance Schedule</h3>
                       <div id="maintenanceChart"></div>
                   </div>
               </div>
           </div>

           <div id="anomalies" class="tab-content">
               <div class="charts-grid">
                   <div class="chart-container">
                       <h3 class="chart-title">üö® Anomaly Detection</h3>
                       <div id="anomalyChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üìâ Performance Outliers</h3>
                       <div id="outlierChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">üîç Behavioral Patterns</h3>
                       <div id="behaviorChart"></div>
                   </div>
                   <div class="chart-container">
                       <h3 class="chart-title">‚ö° Real-time Alerts</h3>
                       <div id="alertsChart"></div>
                   </div>
               </div>
           </div>

           <!-- Recommendations Section -->
           <div class="recommendations-section" id="recommendationsSection">
               <h2 class="recommendations-title">
                   üí° Intelligent Recommendations
               </h2>
               <div id="recommendationsContent">
                   <!-- Recommendations will be populated here -->
               </div>
           </div>

           <!-- Export Section -->
           <div class="export-section">
               <h3>üì§ Export Analysis Results</h3>
               <p>Download comprehensive reports and data in various formats</p>
               <div class="export-buttons">
                   <button class="export-btn excel" onclick="exportToExcel()">
                       üìä Excel Report
                   </button>
                   <button class="export-btn pdf" onclick="exportToPDF()">
                       üìã PDF Report
                   </button>
                   <button class="export-btn json" onclick="exportToJSON()">
                       üíæ JSON Data
                   </button>
                   <button class="export-btn" onclick="generateCustomReport()">
                       üé® Custom Report
                   </button>
               </div>
           </div>
       </div>

       <!-- Footer -->
       <div class="footer">
           <p>üöÄ Advanced Network Analyzer | Version 4.0.0 | Generated with ‚ù§Ô∏è</p>
           <p><small>Complete network performance monitoring and analysis solution</small></p>
       </div>
   </div>

   <!-- Live Updates Indicator -->
   <div class="live-indicator" id="liveIndicator">
       Live Updates
   </div>

   <script>
       let networkData = null;
       let deviceStats = {};
       let analysisResults = {};
       let currentFilter = 'all';

       // File upload handling
       document.addEventListener('DOMContentLoaded', function() {
           const uploadArea = document.getElementById('uploadArea');
           const fileInput = document.getElementById('fileInput');

           // Drag and drop
           uploadArea.addEventListener('dragover', (e) => {
               e.preventDefault();
               uploadArea.classList.add('dragover');
           });

           uploadArea.addEventListener('dragleave', () => {
               uploadArea.classList.remove('dragover');
           });

           uploadArea.addEventListener('drop', (e) => {
               e.preventDefault();
               uploadArea.classList.remove('dragover');
               const files = e.dataTransfer.files;
               if (files.length > 0) {
                   handleFile(files[0]);
               }
           });

           uploadArea.addEventListener('click', () => {
               fileInput.click();
           });

           fileInput.addEventListener('change', (e) => {
               if (e.target.files.length > 0) {
                   handleFile(e.target.files[0]);
               }
           });

           // Filter buttons
           document.querySelectorAll('.filter-btn').forEach(btn => {
               btn.addEventListener('click', (e) => {
                   document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
                   e.target.classList.add('active');
                   currentFilter = e.target.dataset.filter;
                   filterDevices();
               });
           });

           // Search functionality
           document.getElementById('deviceSearch').addEventListener('input', (e) => {
               filterDevices(e.target.value);
           });
       });

       function handleFile(file) {
           if (!file.name.endsWith('.csv')) {
               alert('Please select a CSV file');
               return;
           }

           document.getElementById('uploadSection').classList.add('hidden');
           document.getElementById('loading').style.display = 'block';

           const reader = new FileReader();
           reader.onload = function(e) {
               const csv = e.target.result;
               parseAndAnalyze(csv);
           };
           reader.readAsText(file);
       }

       function loadSampleData() {
           // Load sample data if available
           if (window.fs && typeof window.fs.readFile === 'function') {
               loadSampleCSV();
           } else {
               alert('Sample data not available. Please upload your own CSV file.');
           }
       }

       async function loadSampleCSV() {
           try {
               const csvContent = await window.fs.readFile('all_history_all_20250613_074840.csv', { encoding: 'utf8' });
               document.getElementById('uploadSection').classList.add('hidden');
               document.getElementById('loading').style.display = 'block';
               parseAndAnalyze(csvContent);
           } catch (error) {
               console.log('Sample data not available');
               alert('Sample data not available. Please upload your own CSV file.');
           }
       }

       function showDataFormat() {
           alert(`Required CSV columns:
- Device Name - Name of the network device
- IP Address - Device IP address  
- Type - Device type (PLC, Client, Gateway, etc.)
- Parent Gateway - Connected gateway name
- Status - Online/Offline status
- Response Time (ms) - Response time in milliseconds
- Timestamp - Date and time of record`);
       }

       function parseAndAnalyze(csvText) {
           // Parse CSV
           Papa.parse(csvText, {
               header: true,
               dynamicTyping: true,
               skipEmptyLines: true,
               complete: function(results) {
                   networkData = results.data;
                   analyzeData();
                   showResults();
               },
               error: function(error) {
                   console.error('CSV parsing error:', error);
                   alert('Error parsing CSV file');
                   resetToUpload();
               }
           });
       }

       function analyzeData() {
           if (!networkData || networkData.length === 0) return;

           // Clean and normalize the data
           networkData = networkData.filter(row =>
               row['Device Name'] && row['Device Name'].trim() !== ''
           );

           // Convert timestamps
           networkData.forEach(row => {
               if (row['Timestamp']) {
                   row['Timestamp'] = new Date(row['Timestamp']);
               }
               if (row['Response Time (ms)']) {
                   row['Response Time (ms)'] = parseFloat(row['Response Time (ms)']) || 0;
               }
           });

           // Calculate comprehensive analysis
           calculateDeviceStats();
           calculateNetworkAnalysis();
           generatePredictions();
           detectAnomalies();
           generateRecommendations();
       }
       function calculateDeviceStats() {
           deviceStats = {};

           networkData.forEach(row => {
               const deviceName = row['Device Name'];
               if (!deviceStats[deviceName]) {
                   deviceStats[deviceName] = {
                       name: deviceName,
                       type: row['Type'] || 'Unknown',
                       ip: row['IP Address'] || 'Unknown',
                       gateway: row['Parent Gateway'] || 'Unknown',
                       totalRecords: 0,
                       onlineRecords: 0,
                       responseTimes: [],
                       lastSeen: null,
                       qualityScore: 0,
                       healthStatus: 'Unknown'
                   };
               }

               const stats = deviceStats[deviceName];
               stats.totalRecords++;

               if (row['Status'] && row['Status'].toLowerCase() === 'online') {
                   stats.onlineRecords++;
                   if (row['Response Time (ms)'] && row['Response Time (ms)'] > 0) {
                       stats.responseTimes.push(row['Response Time (ms)']);
                   }
               }

               if (row['Timestamp'] && (!stats.lastSeen || row['Timestamp'] > stats.lastSeen)) {
                   stats.lastSeen = row['Timestamp'];
               }
           });

           // Calculate derived metrics
           Object.values(deviceStats).forEach(stats => {
               stats.uptime = stats.totalRecords > 0 ? (stats.onlineRecords / stats.totalRecords) * 100 : 0;
               stats.avgResponseTime = stats.responseTimes.length > 0
                   ? stats.responseTimes.reduce((a, b) => a + b, 0) / stats.responseTimes.length
                   : 0;
               stats.maxResponseTime = stats.responseTimes.length > 0
                   ? Math.max(...stats.responseTimes)
                   : 0;
               stats.minResponseTime = stats.responseTimes.length > 0
                   ? Math.min(...stats.responseTimes)
                   : 0;

               // Calculate MTBF and MTTR
               const reliability = calculateReliabilityMetrics(stats.name);
               stats.mtbf = reliability.mtbf;
               stats.mttr = reliability.mttr;

               // Quality assessment
               stats.qualityScore = calculateQualityScore(stats.uptime, stats.avgResponseTime);
               stats.healthStatus = determineHealthStatus(stats.qualityScore, stats.uptime);
           });
       }

       function calculateReliabilityMetrics(deviceName) {
           const deviceData = networkData.filter(row => row['Device Name'] === deviceName)
                                        .sort((a, b) => new Date(a.Timestamp) - new Date(b.Timestamp));
           
           let onlinePeriods = [];
           let offlinePeriods = [];
           let currentState = null;
           let stateStartTime = null;

           deviceData.forEach(row => {
               const status = row['Status']?.toLowerCase();
               const timestamp = new Date(row['Timestamp']);

               if (currentState !== status) {
                   if (currentState !== null && stateStartTime) {
                       const duration = (timestamp - stateStartTime) / (1000 * 60 * 60); // hours
                       if (currentState === 'online') {
                           onlinePeriods.push(duration);
                       } else {
                           offlinePeriods.push(duration);
                       }
                   }
                   currentState = status;
                   stateStartTime = timestamp;
               }
           });

           const mtbf = onlinePeriods.length > 0 ? onlinePeriods.reduce((a, b) => a + b, 0) / onlinePeriods.length : 0;
           const mttr = offlinePeriods.length > 0 ? offlinePeriods.reduce((a, b) => a + b, 0) / offlinePeriods.length : 0;

           return { mtbf, mttr };
       }

       function calculateQualityScore(uptime, avgResponseTime) {
           let score = 0;
           
           // Uptime score (40 points)
           score += Math.min(uptime * 0.4, 40);
           
           // Response time score (35 points)
           if (avgResponseTime <= 50) score += 35;
           else if (avgResponseTime <= 100) score += 30;
           else if (avgResponseTime <= 200) score += 20;
           else if (avgResponseTime <= 500) score += 10;
           else score += 5;
           
           // Stability score (25 points) - simplified
           if (avgResponseTime > 0) {
               const stability = Math.max(0, 25 - (avgResponseTime / 20));
               score += stability;
           }
           
           return Math.round(score);
       }

       function determineHealthStatus(qualityScore, uptime) {
           if (qualityScore >= 90 && uptime >= 95) return 'excellent';
           if (qualityScore >= 75 && uptime >= 85) return 'good';
           if (qualityScore >= 60 && uptime >= 70) return 'fair';
           return 'poor';
       }

       function calculateNetworkAnalysis() {
           analysisResults.gateways = {};
           analysisResults.subnets = {};
           analysisResults.deviceTypes = {};

           // Gateway analysis
           const gateways = [...new Set(networkData.map(row => row['Parent Gateway']))];
           gateways.forEach(gateway => {
               if (!gateway) return;
               
               const gatewayData = networkData.filter(row => row['Parent Gateway'] === gateway);
               const onlineCount = gatewayData.filter(row => row['Status']?.toLowerCase() === 'online').length;
               
               analysisResults.gateways[gateway] = {
                   deviceCount: new Set(gatewayData.map(row => row['Device Name'])).size,
                   totalRecords: gatewayData.length,
                   uptime: gatewayData.length > 0 ? (onlineCount / gatewayData.length) * 100 : 0,
                   avgResponseTime: calculateAvgResponseTime(gatewayData)
               };
           });

           // Subnet analysis
           const subnets = [...new Set(networkData.map(row => {
               const ip = row['IP Address'];
               return ip ? ip.split('.').slice(0, 3).join('.') + '.0/24' : null;
           }))].filter(Boolean);

           subnets.forEach(subnet => {
               const subnetPrefix = subnet.split('/')[0].split('.').slice(0, 3).join('.');
               const subnetData = networkData.filter(row => 
                   row['IP Address']?.startsWith(subnetPrefix)
               );
               const onlineCount = subnetData.filter(row => row['Status']?.toLowerCase() === 'online').length;
               
               analysisResults.subnets[subnet] = {
                   deviceCount: new Set(subnetData.map(row => row['Device Name'])).size,
                   uptime: subnetData.length > 0 ? (onlineCount / subnetData.length) * 100 : 0,
                   avgResponseTime: calculateAvgResponseTime(subnetData)
               };
           });

           // Device type analysis
           const types = [...new Set(networkData.map(row => row['Type']))];
           types.forEach(type => {
               if (!type) return;
               
               const typeData = networkData.filter(row => row['Type'] === type);
               const onlineCount = typeData.filter(row => row['Status']?.toLowerCase() === 'online').length;
               
               analysisResults.deviceTypes[type] = {
                   count: new Set(typeData.map(row => row['Device Name'])).size,
                   uptime: typeData.length > 0 ? (onlineCount / typeData.length) * 100 : 0,
                   avgResponseTime: calculateAvgResponseTime(typeData)
               };
           });
       }

       function calculateAvgResponseTime(data) {
           const responseTimes = data
               .filter(row => row['Status']?.toLowerCase() === 'online' && row['Response Time (ms)'] > 0)
               .map(row => row['Response Time (ms)']);
           
           return responseTimes.length > 0 
               ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length 
               : 0;
       }

       function generatePredictions() {
           analysisResults.predictions = {};
           
           Object.keys(deviceStats).forEach(deviceName => {
               const stats = deviceStats[deviceName];
               const deviceData = networkData.filter(row => row['Device Name'] === deviceName);
               
               // Simple trend analysis
               const recentData = deviceData.slice(-100); // Last 100 records
               const recentUptime = recentData.filter(row => row['Status']?.toLowerCase() === 'online').length / recentData.length * 100;
               
               // Risk assessment
               let riskScore = 0;
               if (stats.uptime < 80) riskScore += 40;
               if (stats.avgResponseTime > 200) riskScore += 30;
               if (recentUptime < stats.uptime) riskScore += 20;
               
               analysisResults.predictions[deviceName] = {
                   riskScore: Math.min(riskScore, 100),
                   predictedUptime: Math.max(0, Math.min(100, recentUptime + (Math.random() - 0.5) * 10)),
                   maintenanceNeeded: riskScore > 60,
                   trend: recentUptime > stats.uptime ? 'improving' : recentUptime < stats.uptime ? 'declining' : 'stable'
               };
           });
       }

       function detectAnomalies() {
           analysisResults.anomalies = {
               responseTimeOutliers: [],
               uptimeAnomalies: [],
               patternAnomalies: []
           };

           // Response time outliers using IQR method
           const responseTimes = networkData
               .filter(row => row['Status']?.toLowerCase() === 'online' && row['Response Time (ms)'] > 0)
               .map(row => row['Response Time (ms)'])
               .sort((a, b) => a - b);

           if (responseTimes.length > 10) {
               const q1 = responseTimes[Math.floor(responseTimes.length * 0.25)];
               const q3 = responseTimes[Math.floor(responseTimes.length * 0.75)];
               const iqr = q3 - q1;
               const lowerBound = q1 - 1.5 * iqr;
               const upperBound = q3 + 1.5 * iqr;

               networkData.forEach(row => {
                   if (row['Status']?.toLowerCase() === 'online' && 
                       row['Response Time (ms)'] > 0 &&
                       (row['Response Time (ms)'] < lowerBound || row['Response Time (ms)'] > upperBound)) {
                       
                       analysisResults.anomalies.responseTimeOutliers.push({
                           device: row['Device Name'],
                           timestamp: row['Timestamp'],
                           responseTime: row['Response Time (ms)'],
                           severity: row['Response Time (ms)'] > upperBound * 2 ? 'critical' : 'warning'
                       });
                   }
               });
           }

           // Uptime anomalies
           Object.keys(deviceStats).forEach(deviceName => {
               const stats = deviceStats[deviceName];
               if (stats.uptime < 70) {
                   analysisResults.anomalies.uptimeAnomalies.push({
                       device: deviceName,
                       uptime: stats.uptime,
                       severity: stats.uptime < 50 ? 'critical' : 'warning'
                   });
               }
           });
       }

       function generateRecommendations() {
           analysisResults.recommendations = {
               critical: [],
               high: [],
               medium: [],
               low: []
           };

           Object.keys(deviceStats).forEach(deviceName => {
               const stats = deviceStats[deviceName];
               const prediction = analysisResults.predictions[deviceName];

               // Critical recommendations
               if (stats.uptime < 50) {
                   analysisResults.recommendations.critical.push({
                       device: deviceName,
                       issue: `Critical uptime: ${stats.uptime.toFixed(1)}%`,
                       recommendation: 'Immediate replacement or major repair required',
                       impact: 'Service disruption likely'
                   });
               }

               // High priority recommendations
               if (stats.uptime < 80 && stats.uptime >= 50) {
                   analysisResults.recommendations.high.push({
                       device: deviceName,
                       issue: `Low uptime: ${stats.uptime.toFixed(1)}%`,
                       recommendation: 'Schedule maintenance within 48 hours',
                       impact: 'Performance degradation'
                   });
               }

               if (stats.avgResponseTime > 500) {
                   analysisResults.recommendations.high.push({
                       device: deviceName,
                       issue: `High response time: ${stats.avgResponseTime.toFixed(0)}ms`,
                       recommendation: 'Check network congestion and device performance',
                       impact: 'User experience affected'
                   });
               }

               // Medium priority recommendations
               if (prediction && prediction.maintenanceNeeded) {
                   analysisResults.recommendations.medium.push({
                       device: deviceName,
                       issue: `Predictive maintenance needed (Risk: ${prediction.riskScore})`,
                       recommendation: 'Schedule preventive maintenance',
                       impact: 'Prevent future issues'
                   });
               }

               // Low priority recommendations
               if (stats.uptime >= 80 && stats.uptime < 95) {
                   analysisResults.recommendations.low.push({
                       device: deviceName,
                       issue: `Uptime can be improved: ${stats.uptime.toFixed(1)}%`,
                       recommendation: 'Monitor closely and optimize configuration',
                       impact: 'Optimization opportunity'
                   });
               }
           });
       }

       function showResults() {
           document.getElementById('loading').style.display = 'none';
           document.getElementById('results').classList.remove('hidden');

           createStatsCards();
           createAllCharts();
           createDeviceCards();
           createRecommendationsSection();
           
           // Show live indicator
           showLiveIndicator();
       }

       function createStatsCards() {
           const totalDevices = Object.keys(deviceStats).length;
           const totalRecords = networkData.length;
           const onlineRecords = networkData.filter(row => 
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           const overallUptime = totalRecords > 0 ? (onlineRecords / totalRecords) * 100 : 0;
           const avgResponseTime = calculateOverallAvgResponseTime();

           const statsHTML = `
               <div class="stat-card">
                   <div class="stat-value">${totalDevices}</div>
                   <div class="stat-label">Total Devices</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${totalRecords.toLocaleString()}</div>
                   <div class="stat-label">Total Records</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${overallUptime.toFixed(1)}%</div>
                   <div class="stat-label">Overall Uptime</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${avgResponseTime.toFixed(0)}ms</div>
                   <div class="stat-label">Avg Response Time</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${Object.keys(analysisResults.gateways || {}).length}</div>
                   <div class="stat-label">Active Gateways</div>
               </div>
               <div class="stat-card">
                   <div class="stat-value">${getHealthyDeviceCount()}</div>
                   <div class="stat-label">Healthy Devices</div>
               </div>
           `;

           document.getElementById('statsGrid').innerHTML = statsHTML;
       }

       function calculateOverallAvgResponseTime() {
           const responseTimes = networkData
               .filter(row => row['Response Time (ms)'] && row['Response Time (ms)'] > 0)
               .map(row => row['Response Time (ms)']);

           return responseTimes.length > 0
               ? responseTimes.reduce((a, b) => a + b, 0) / responseTimes.length
               : 0;
       }

       function getHealthyDeviceCount() {
           return Object.values(deviceStats).filter(stats => 
               stats.healthStatus === 'excellent' || stats.healthStatus === 'good'
           ).length;
       }

       function createAllCharts() {
           createStatusChart();
           createResponseTimeChart();
           createHourlyChart();
           createHeatmapChart();
           createDistributionChart();
           createGatewayChart();
           createTopologyChart();
           createConnectionChart();
           createQualityChart();
           createReliabilityChart();
           createSubnetChart();
           createLoadChart();
           createPredictionCharts();
           createAnomalyCharts();
       }

       function createStatusChart() {
           const onlineCount = networkData.filter(row =>
               row['Status'] && row['Status'].toLowerCase() === 'online'
           ).length;
           const offlineCount = networkData.length - onlineCount;

           const data = [{
               values: [onlineCount, offlineCount],
               labels: ['Online', 'Offline'],
               type: 'pie',
               marker: {
                   colors: ['#06d6a0', '#ef476f']
               },
               hole: 0.4
           }];

           const layout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 }
           };

           Plotly.newPlot('statusChart', data, layout, {responsive: true});
       }

       function createResponseTimeChart() {
           // Group data by hour and calculate average response time
           const hourlyData = {};

           networkData.forEach(row => {
               if (row['Timestamp'] && row['Response Time (ms)'] && row['Response Time (ms)'] > 0) {
                   const hour = new Date(row['Timestamp']).getHours();
                   if (!hourlyData[hour]) {
                       hourlyData[hour] = [];
                   }
                   hourlyData[hour].push(row['Response Time (ms)']);
               }
           });

           const hours = [];
           const avgResponseTimes = [];

           for (let hour = 0; hour < 24; hour++) {
               hours.push(hour);
               if (hourlyData[hour] && hourlyData[hour].length > 0) {
                   const avg = hourlyData[hour].reduce((a, b) => a + b, 0) / hourlyData[hour].length;
                   avgResponseTimes.push(avg);
               } else {
                   avgResponseTimes.push(0);
               }
           }

           const data = [{
               x: hours,
               y: avgResponseTimes,
               type: 'scatter',
               mode: 'lines+markers',
               line: { color: '#667eea', width: 3 },
               marker: { size: 8, color: '#667eea' },
               fill: 'tonexty',
               fillcolor: 'rgba(102, 126, 234, 0.1)'
           }];

           const layout = {
               xaxis: { title: 'Hour of Day' },
               yaxis: { title: 'Avg Response Time (ms)' },
               height: 350,
               margin: { t: 20, b: 50, l: 50, r: 20 }
           };

           Plotly.newPlot('responseTimeChart', data, layout, {responsive: true});
       }

       function createHourlyChart() {
           // Calculate uptime percentage by hour
           const hourlyUptime = {};

           for (let hour = 0; hour < 24; hour++) {
               const hourData = networkData.filter(row =>
                   row['Timestamp'] && new Date(row['Timestamp']).getHours() === hour
               );
               const onlineCount = hourData.filter(row =>
                   row['Status'] && row['Status'].toLowerCase() === 'online'
               ).length;

               hourlyUptime[hour] = hourData.length > 0 ? (onlineCount / hourData.length) * 100 : 0;
           }

           const hours = Object.keys(hourlyUptime).map(Number);
           const uptimes = Object.values(hourlyUptime);

           const data = [{
               x: hours,
               y: uptimes,
               type: 'bar',
               marker: {
                   color: uptimes.map(uptime =>
                       uptime >= 90 ? '#06d6a0' :
                       uptime >= 70 ? '#f78c6b' : '#ef476f'
                   )
               }
           }];

           const layout = {
               xaxis: { title: 'Hour of Day' },
               yaxis: { title: 'Uptime Percentage' },
               height: 350,
               margin: { t: 20, b: 50, l: 50, r: 20 }
           };

           Plotly.newPlot('hourlyChart', data, layout, {responsive: true});
       }

       function createHeatmapChart() {
           // Create device-hour heatmap
           const devices = [...new Set(networkData.map(row => row['Device Name']))].slice(0, 15);
           const hours = Array.from({length: 24}, (_, i) => i);

           const heatmapData = devices.map(device => {
               return hours.map(hour => {
                   const deviceHourData = networkData.filter(row =>
                       row['Device Name'] === device &&
                       row['Timestamp'] &&
                       new Date(row['Timestamp']).getHours() === hour
                   );

                   if (deviceHourData.length === 0) return 0;

                   const onlineCount = deviceHourData.filter(row =>
                       row['Status'] && row['Status'].toLowerCase() === 'online'
                   ).length;

                   return (onlineCount / deviceHourData.length) * 100;
               });
           });

           const data = [{
               z: heatmapData,
               x: hours,
               y: devices,
               type: 'heatmap',
               colorscale: 'RdYlGn',
               showscale: true
           }];

           const layout = {
               xaxis: { title: 'Hour of Day' },
               yaxis: { title: 'Device' },
               height: 350,
               margin: { t: 20, b: 50, l: 150, r: 20 }
           };

           Plotly.newPlot('heatmapChart', data, layout, {responsive: true});
       }

       function createDistributionChart() {
           const responseTimes = networkData
               .filter(row => row['Response Time (ms)'] && row['Response Time (ms)'] > 0)
               .map(row => row['Response Time (ms)']);

           const data = [{
               x: responseTimes,
               type: 'histogram',
               nbinsx: 30,
               marker: { color: '#667eea', opacity: 0.7 }
           }];

           const layout = {
               xaxis: { title: 'Response Time (ms)' },
               yaxis: { title: 'Frequency' },
               height: 350,
               margin: { t: 20, b: 50, l: 50, r: 20 }
           };

           Plotly.newPlot('distributionChart', data, layout, {responsive: true});
       }

       function createGatewayChart() {
           const gateways = Object.keys(analysisResults.gateways || {});
           const uptimes = gateways.map(gw => analysisResults.gateways[gw].uptime);

           const data = [{
               x: gateways,
               y: uptimes,
               type: 'bar',
               marker: {
                   color: uptimes.map(uptime =>
                       uptime >= 90 ? '#06d6a0' :
                       uptime >= 70 ? '#f78c6b' : '#ef476f'
                   )
               }
           }];

           const layout = {
               xaxis: { title: 'Gateway' },
               yaxis: { title: 'Uptime Percentage' },
               height: 350,
               margin: { t: 20, b: 50, l: 50, r: 20 }
           };

           Plotly.newPlot('gatewayChart', data, layout, {responsive: true});
       }
       function createTopologyChart() {
           // Create network topology visualization
           const gateways = [...new Set(networkData.map(row => row['Parent Gateway']).filter(Boolean))];
           const devices = [...new Set(networkData.map(row => row['Device Name']))];

           // Create nodes for network topology
           const gatewayNodes = gateways.map((gw, i) => ({
               x: Math.cos(2 * Math.PI * i / gateways.length) * 2,
               y: Math.sin(2 * Math.PI * i / gateways.length) * 2,
               text: gw,
               type: 'gateway'
           }));

           const deviceNodes = devices.slice(0, 20).map((device, i) => {
               const deviceData = networkData.find(row => row['Device Name'] === device);
               const gateway = deviceData ? deviceData['Parent Gateway'] : null;
               const gatewayIndex = gateways.indexOf(gateway);
               
               if (gatewayIndex !== -1) {
                   const angle = (2 * Math.PI * i / 20) + (gatewayIndex * 0.5);
                   const radius = 1 + Math.random() * 0.5;
                   return {
                       x: gatewayNodes[gatewayIndex].x + Math.cos(angle) * radius,
                       y: gatewayNodes[gatewayIndex].y + Math.sin(angle) * radius,
                       text: device,
                       type: deviceData ? deviceData['Type'] : 'Unknown'
                   };
               }
               return {
                   x: Math.random() * 6 - 3,
                   y: Math.random() * 6 - 3,
                   text: device,
                   type: 'Unknown'
               };
           });

           // Create edges
           const edgeTrace = {
               x: [],
               y: [],
               mode: 'lines',
               line: { color: '#cbd5e1', width: 1 },
               showlegend: false,
               hoverinfo: 'none'
           };

           devices.slice(0, 20).forEach(device => {
               const deviceData = networkData.find(row => row['Device Name'] === device);
               if (deviceData && deviceData['Parent Gateway']) {
                   const gatewayIndex = gateways.indexOf(deviceData['Parent Gateway']);
                   const deviceIndex = devices.slice(0, 20).indexOf(device);
                   
                   if (gatewayIndex !== -1 && deviceIndex !== -1) {
                       edgeTrace.x.push(gatewayNodes[gatewayIndex].x, deviceNodes[deviceIndex].x, null);
                       edgeTrace.y.push(gatewayNodes[gatewayIndex].y, deviceNodes[deviceIndex].y, null);
                   }
               }
           });

           const traces = [
               edgeTrace,
               {
                   x: gatewayNodes.map(n => n.x),
                   y: gatewayNodes.map(n => n.y),
                   mode: 'markers+text',
                   marker: { size: 15, color: '#ef476f', symbol: 'square' },
                   text: gatewayNodes.map(n => n.text),
                   textposition: 'middle center',
                   name: 'Gateways'
               },
               {
                   x: deviceNodes.map(n => n.x),
                   y: deviceNodes.map(n => n.y),
                   mode: 'markers',
                   marker: { 
                       size: 8, 
                       color: deviceNodes.map(n => {
                           switch(n.type) {
                               case 'PLC': return '#118ab2';
                               case 'Client': return '#06d6a0';
                               case 'Gateway': return '#ef476f';
                               default: return '#667eea';
                           }
                       })
                   },
                   text: deviceNodes.map(n => n.text),
                   name: 'Devices'
               }
           ];

           const layout = {
               showlegend: true,
               xaxis: { showgrid: false, showticklabels: false, zeroline: false },
               yaxis: { showgrid: false, showticklabels: false, zeroline: false },
               height: 350,
               margin: { t: 20, b: 20, l: 20, r: 20 }
           };

           Plotly.newPlot('topologyChart', traces, layout, {responsive: true});
       }

       function createConnectionChart() {
           // Device type distribution
           const deviceTypes = {};
           networkData.forEach(row => {
               const type = row['Type'] || 'Unknown';
               deviceTypes[type] = (deviceTypes[type] || 0) + 1;
           });

           const data = [{
               labels: Object.keys(deviceTypes),
               values: Object.values(deviceTypes),
               type: 'pie',
               marker: {
                   colors: ['#667eea', '#06d6a0', '#f78c6b', '#ef476f', '#118ab2']
               }
           }];

           const layout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 }
           };

           Plotly.newPlot('connectionChart', data, layout, {responsive: true});
       }

       function createQualityChart() {
           const devices = Object.keys(deviceStats).slice(0, 15);
           const qualityScores = devices.map(device => deviceStats[device].qualityScore);
           const colors = devices.map(device => {
               const score = deviceStats[device].qualityScore;
               if (score >= 90) return '#06d6a0';
               if (score >= 75) return '#28a745';
               if (score >= 60) return '#f78c6b';
               return '#ef476f';
           });

           const data = [{
               x: devices,
               y: qualityScores,
               type: 'bar',
               marker: { color: colors }
           }];

           const layout = {
               xaxis: { title: 'Device', tickangle: -45 },
               yaxis: { title: 'Quality Score' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('qualityChart', data, layout, {responsive: true});
       }

       function createReliabilityChart() {
           const devices = Object.keys(deviceStats).slice(0, 10);
           const mtbfValues = devices.map(device => deviceStats[device].mtbf);
           const mttrValues = devices.map(device => deviceStats[device].mttr);

           const data = [
               {
                   x: devices,
                   y: mtbfValues,
                   type: 'bar',
                   name: 'MTBF (hours)',
                   marker: { color: '#06d6a0' }
               },
               {
                   x: devices,
                   y: mttrValues,
                   type: 'bar',
                   name: 'MTTR (hours)',
                   marker: { color: '#ef476f' }
               }
           ];

           const layout = {
               barmode: 'group',
               xaxis: { title: 'Device', tickangle: -45 },
               yaxis: { title: 'Time (hours)' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('reliabilityChart', data, layout, {responsive: true});
       }

       function createSubnetChart() {
           const subnets = Object.keys(analysisResults.subnets || {});
           const uptimes = subnets.map(subnet => analysisResults.subnets[subnet].uptime);

           const data = [{
               x: subnets,
               y: uptimes,
               type: 'bar',
               marker: {
                   color: uptimes.map(uptime =>
                       uptime >= 90 ? '#06d6a0' :
                       uptime >= 70 ? '#f78c6b' : '#ef476f'
                   )
               }
           }];

           const layout = {
               xaxis: { title: 'Subnet', tickangle: -45 },
               yaxis: { title: 'Uptime Percentage' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('subnetChart', data, layout, {responsive: true});
       }

       function createLoadChart() {
           const gateways = Object.keys(analysisResults.gateways || {});
           const deviceCounts = gateways.map(gw => analysisResults.gateways[gw].deviceCount);

           const data = [{
               labels: gateways,
               values: deviceCounts,
               type: 'pie',
               hole: 0.3,
               marker: {
                   colors: ['#667eea', '#06d6a0', '#f78c6b', '#ef476f', '#118ab2', '#764ba2']
               }
           }];

           const layout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 }
           };

           Plotly.newPlot('loadChart', data, layout, {responsive: true});
       }

       function createPredictionCharts() {
           // Uptime prediction chart
           const devices = Object.keys(analysisResults.predictions || {}).slice(0, 10);
           const currentUptimes = devices.map(device => deviceStats[device].uptime);
           const predictedUptimes = devices.map(device => analysisResults.predictions[device].predictedUptime);

           const uptimeData = [
               {
                   x: devices,
                   y: currentUptimes,
                   type: 'bar',
                   name: 'Current Uptime',
                   marker: { color: '#667eea' }
               },
               {
                   x: devices,
                   y: predictedUptimes,
                   type: 'bar',
                   name: 'Predicted Uptime',
                   marker: { color: '#06d6a0' }
               }
           ];

           const uptimeLayout = {
               barmode: 'group',
               xaxis: { title: 'Device', tickangle: -45 },
               yaxis: { title: 'Uptime %' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('uptimePredictionChart', uptimeData, uptimeLayout, {responsive: true});

           // Response forecast chart
           const responseTrends = devices.map(device => {
               const current = deviceStats[device].avgResponseTime;
               const trend = analysisResults.predictions[device].trend;
               let forecast = current;
               
               if (trend === 'improving') forecast *= 0.9;
               else if (trend === 'declining') forecast *= 1.1;
               
               return forecast;
           });

           const responseData = [
               {
                   x: devices,
                   y: devices.map(device => deviceStats[device].avgResponseTime),
                   type: 'bar',
                   name: 'Current Response Time',
                   marker: { color: '#f78c6b' }
               },
               {
                   x: devices,
                   y: responseTrends,
                   type: 'bar',
                   name: 'Forecasted Response Time',
                   marker: { color: '#ef476f' }
               }
           ];

           const responseLayout = {
               barmode: 'group',
               xaxis: { title: 'Device', tickangle: -45 },
               yaxis: { title: 'Response Time (ms)' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('responseForecastChart', responseData, responseLayout, {responsive: true});

           // Risk assessment chart
           const riskScores = devices.map(device => analysisResults.predictions[device].riskScore);

           const riskData = [{
               x: devices,
               y: riskScores,
               type: 'bar',
               marker: {
                   color: riskScores.map(score =>
                       score >= 70 ? '#ef476f' :
                       score >= 40 ? '#f78c6b' : '#06d6a0'
                   )
               }
           }];

           const riskLayout = {
               xaxis: { title: 'Device', tickangle: -45 },
               yaxis: { title: 'Risk Score' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('riskChart', riskData, riskLayout, {responsive: true});

           // Maintenance schedule chart
           const maintenanceNeeded = devices.filter(device => 
               analysisResults.predictions[device].maintenanceNeeded
           );
           const noMaintenance = devices.length - maintenanceNeeded.length;

           const maintenanceData = [{
               labels: ['Maintenance Needed', 'No Maintenance Required'],
               values: [maintenanceNeeded.length, noMaintenance],
               type: 'pie',
               marker: {
                   colors: ['#ef476f', '#06d6a0']
               }
           }];

           const maintenanceLayout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 }
           };

           Plotly.newPlot('maintenanceChart', maintenanceData, maintenanceLayout, {responsive: true});
       }

       function createAnomalyCharts() {
           // Anomaly detection chart
           const anomalies = analysisResults.anomalies;
           const severityCounts = {
               critical: 0,
               warning: 0,
               info: 0
           };

           // Count anomalies by severity
           anomalies.responseTimeOutliers.forEach(anomaly => {
               severityCounts[anomaly.severity] = (severityCounts[anomaly.severity] || 0) + 1;
           });

           anomalies.uptimeAnomalies.forEach(anomaly => {
               severityCounts[anomaly.severity] = (severityCounts[anomaly.severity] || 0) + 1;
           });

           const anomalyData = [{
               labels: ['Critical', 'Warning', 'Info'],
               values: [severityCounts.critical, severityCounts.warning, severityCounts.info],
               type: 'pie',
               marker: {
                   colors: ['#ef476f', '#f78c6b', '#118ab2']
               }
           }];

           const anomalyLayout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 }
           };

           Plotly.newPlot('anomalyChart', anomalyData, anomalyLayout, {responsive: true});

           // Performance outliers chart
           const outlierDevices = anomalies.responseTimeOutliers.map(anomaly => anomaly.device);
           const outlierResponseTimes = anomalies.responseTimeOutliers.map(anomaly => anomaly.responseTime);

           const outlierData = [{
               x: outlierDevices.slice(0, 15),
               y: outlierResponseTimes.slice(0, 15),
               type: 'scatter',
               mode: 'markers',
               marker: {
                   size: 12,
                   color: '#ef476f',
                   symbol: 'x'
               }
           }];

           const outlierLayout = {
               xaxis: { title: 'Device', tickangle: -45 },
               yaxis: { title: 'Response Time (ms)' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('outlierChart', outlierData, outlierLayout, {responsive: true});

           // Behavioral patterns chart
           const healthStatusCounts = {};
           Object.values(deviceStats).forEach(stats => {
               const status = stats.healthStatus;
               healthStatusCounts[status] = (healthStatusCounts[status] || 0) + 1;
           });

           const behaviorData = [{
               labels: Object.keys(healthStatusCounts),
               values: Object.values(healthStatusCounts),
               type: 'pie',
               marker: {
                   colors: ['#06d6a0', '#28a745', '#f78c6b', '#ef476f']
               }
           }];

           const behaviorLayout = {
               showlegend: true,
               height: 350,
               margin: { t: 0, b: 0, l: 0, r: 0 }
           };

           Plotly.newPlot('behaviorChart', behaviorData, behaviorLayout, {responsive: true});

           // Real-time alerts chart (simulated)
           const alertTypes = ['High Response Time', 'Low Uptime', 'Connection Lost', 'Gateway Issue'];
           const alertCounts = alertTypes.map(() => Math.floor(Math.random() * 10));

           const alertsData = [{
               x: alertTypes,
               y: alertCounts,
               type: 'bar',
               marker: {
                   color: ['#ef476f', '#f78c6b', '#764ba2', '#118ab2']
               }
           }];

           const alertsLayout = {
               xaxis: { title: 'Alert Type', tickangle: -45 },
               yaxis: { title: 'Count' },
               height: 350,
               margin: { t: 20, b: 100, l: 50, r: 20 }
           };

           Plotly.newPlot('alertsChart', alertsData, alertsLayout, {responsive: true});
       }

       function createDeviceCards() {
           const deviceArray = Object.values(deviceStats)
               .sort((a, b) => b.uptime - a.uptime);

           const cardsHTML = deviceArray.map(device => `
               <div class="device-card ${device.healthStatus}" data-device="${device.name}" data-health="${device.healthStatus}">
                   <div class="device-header">
                       <div class="device-name">${device.name}</div>
                       <div class="device-status ${device.uptime > 80 ? 'status-online' : 'status-offline'}">
                           ${device.type}
                       </div>
                   </div>
                   <div class="progress-bar">
                       <div class="progress-fill progress-${device.healthStatus}"
                            style="width: ${device.uptime}%"></div>
                   </div>
                   <p style="margin: 5px 0; font-size: 0.9rem;">
                       <span class="performance-indicator indicator-${device.healthStatus}"></span>
                       Uptime: ${device.uptime.toFixed(1)}% | Quality Score: ${device.qualityScore}
                   </p>
                   <div class="device-metrics">
                       <div class="metric tooltip" data-tooltip="Average response time when online">
                           <div class="metric-value">${device.avgResponseTime.toFixed(0)}</div>
                           <div class="metric-label">Avg Response (ms)</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="Total number of records">
                           <div class="metric-value">${device.totalRecords}</div>
                           <div class="metric-label">Total Records</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="Connected gateway">
                           <div class="metric-value">${device.gateway}</div>
                           <div class="metric-label">Gateway</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="Device IP address">
                           <div class="metric-value">${device.ip}</div>
                           <div class="metric-label">IP Address</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="Mean Time Between Failures">
                           <div class="metric-value">${device.mtbf.toFixed(1)}h</div>
                           <div class="metric-label">MTBF</div>
                       </div>
                       <div class="metric tooltip" data-tooltip="Mean Time To Recovery">
                           <div class="metric-value">${device.mttr.toFixed(1)}h</div>
                           <div class="metric-label">MTTR</div>
                       </div>
                   </div>
               </div>
           `).join('');

           document.getElementById('deviceGrid').innerHTML = cardsHTML;
       }

       function createRecommendationsSection() {
           const recommendations = analysisResults.recommendations;
           let html = '';

           if (recommendations.critical.length > 0) {
               html += `
                   <div class="recommendation-category">
                       <h3 class="category-title">üî¥ Critical Issues</h3>
                       ${recommendations.critical.map(rec => `
                           <div class="recommendation-item critical">
                               <div class="recommendation-device">${rec.device}</div>
                               <div class="recommendation-text">${rec.recommendation}</div>
                               <div class="recommendation-issue">${rec.issue} - ${rec.impact}</div>
                           </div>
                       `).join('')}
                   </div>
               `;
           }

           if (recommendations.high.length > 0) {
               html += `
                   <div class="recommendation-category">
                       <h3 class="category-title">üü° High Priority</h3>
                       ${recommendations.high.map(rec => `
                           <div class="recommendation-item high">
                               <div class="recommendation-device">${rec.device}</div>
                               <div class="recommendation-text">${rec.recommendation}</div>
                               <div class="recommendation-issue">${rec.issue} - ${rec.impact}</div>
                           </div>
                       `).join('')}
                   </div>
               `;
           }

           if (recommendations.medium.length > 0) {
               html += `
                   <div class="recommendation-category">
                       <h3 class="category-title">üü† Medium Priority</h3>
                       ${recommendations.medium.slice(0, 5).map(rec => `
                           <div class="recommendation-item medium">
                               <div class="recommendation-device">${rec.device}</div>
                               <div class="recommendation-text">${rec.recommendation}</div>
                               <div class="recommendation-issue">${rec.issue} - ${rec.impact}</div>
                           </div>
                       `).join('')}
                   </div>
               `;
           }

           if (recommendations.low.length > 0) {
               html += `
                   <div class="recommendation-category">
                       <h3 class="category-title">üü¢ Optimization Opportunities</h3>
                       ${recommendations.low.slice(0, 3).map(rec => `
                           <div class="recommendation-item low">
                               <div class="recommendation-device">${rec.device}</div>
                               <div class="recommendation-text">${rec.recommendation}</div>
                               <div class="recommendation-issue">${rec.issue} - ${rec.impact}</div>
                           </div>
                       `).join('')}
                   </div>
               `;
           }

           if (html === '') {
               html = '<p>üéâ No issues detected! Your network is performing optimally.</p>';
           }

           document.getElementById('recommendationsContent').innerHTML = html;
       }

       function filterDevices(searchTerm = '') {
           const deviceCards = document.querySelectorAll('.device-card');
           
           deviceCards.forEach(card => {
               const deviceName = card.dataset.device.toLowerCase();
               const healthStatus = card.dataset.health;
               
               const matchesSearch = searchTerm === '' || deviceName.includes(searchTerm.toLowerCase());
               const matchesFilter = currentFilter === 'all' || healthStatus === currentFilter;
               
               if (matchesSearch && matchesFilter) {
                   card.style.display = 'block';
               } else {
                   card.style.display = 'none';
               }
           });
       }

       function showTab(tabName) {
           // Hide all tab contents
           const tabContents = document.querySelectorAll('.tab-content');
           tabContents.forEach(content => content.classList.remove('active'));
           
           // Remove active class from all tabs
           const tabs = document.querySelectorAll('.tab');
           tabs.forEach(tab => tab.classList.remove('active'));
           
           // Show selected tab content
           document.getElementById(tabName).classList.add('active');
           
           // Add active class to clicked tab
           event.target.classList.add('active');

           // Redraw charts to ensure proper sizing
           setTimeout(() => {
               const charts = ['statusChart', 'responseTimeChart', 'hourlyChart', 'heatmapChart',
                             'distributionChart', 'gatewayChart', 'topologyChart', 'connectionChart',
                             'qualityChart', 'reliabilityChart', 'subnetChart', 'loadChart',
                             'uptimePredictionChart', 'responseForecastChart', 'riskChart', 
                             'maintenanceChart', 'anomalyChart', 'outlierChart', 'behaviorChart', 'alertsChart'];
               
               charts.forEach(chartId => {
                   const element = document.getElementById(chartId);
                   if (element && element.children.length > 0) {
                       Plotly.Plots.resize(element);
                   }
               });
           }, 100);
       }

       function showLiveIndicator() {
           const indicator = document.getElementById('liveIndicator');
           indicator.classList.add('show');
           
           setTimeout(() => {
               indicator.classList.remove('show');
           }, 3000);
       }

       function resetToUpload() {
           document.getElementById('uploadSection').classList.remove('hidden');
           document.getElementById('loading').style.display = 'none';
           document.getElementById('results').classList.add('hidden');
       }

       // Export functions
       function exportToExcel() {
           if (!networkData) {
               alert('No data to export');
               return;
           }
           
           // Create CSV content
           const headers = ['Device Name', 'Type', 'IP Address', 'Gateway', 'Uptime %', 'Avg Response Time', 'Quality Score', 'Health Status', 'MTBF', 'MTTR'];
           const csvContent = [
               headers.join(','),
               ...Object.values(deviceStats).map(device => [
                   device.name,
                   device.type,
                   device.ip,
                   device.gateway,
                   device.uptime.toFixed(2),
                   device.avgResponseTime.toFixed(2),
                   device.qualityScore,
                   device.healthStatus,
                   device.mtbf.toFixed(2),
                   device.mttr.toFixed(2)
               ].join(','))
           ].join('\n');
           
           downloadFile(csvContent, 'network_analysis_report.csv', 'text/csv');
       }

       function exportToPDF() {
           alert('PDF export functionality would be implemented with a PDF library');
       }

       function exportToJSON() {
           if (!networkData) {
               alert('No data to export');
               return;
           }
           
           const exportData = {
               summary: {
                   totalDevices: Object.keys(deviceStats).length,
                   totalRecords: networkData.length,
                   overallUptime: (networkData.filter(row => row['Status']?.toLowerCase() === 'online').length / networkData.length * 100).toFixed(2),
                   exportDate: new Date().toISOString()
               },
               deviceStats: deviceStats,
               analysisResults: analysisResults
           };
           
           const jsonContent = JSON.stringify(exportData, null, 2);
           downloadFile(jsonContent, 'network_analysis_data.json', 'application/json');
       }

       function generateCustomReport() {
           alert('Custom report generator would allow users to select specific metrics and visualizations');
       }

       function downloadFile(content, filename, mimeType) {
           const blob = new Blob([content], { type: mimeType });
           const url = URL.createObjectURL(blob);
           const link = document.createElement('a');
           link.href = url;
           link.download = filename;
           document.body.appendChild(link);
           link.click();
           document.body.removeChild(link);
           URL.revokeObjectURL(url);
       }

       // Auto-load sample data if available
       window.addEventListener('load', () => {
           // Check if we have access to the uploaded CSV file
           if (window.fs && typeof window.fs.readFile === 'function') {
               setTimeout(() => {
                   loadSampleCSV();
               }, 1000);
           }
       });

       // Real-time updates simulation
       setInterval(() => {
           if (networkData && networkData.length > 0) {
               // Simulate some real-time updates
               const randomDevice = Object.keys(deviceStats)[Math.floor(Math.random() * Object.keys(deviceStats).length)];
               if (randomDevice && Math.random() > 0.95) { // 5% chance of update
                   showLiveIndicator();
               }
           }
       }, 10000); 
   </script>
</body>
</html>
